import * as jsDevTools from "@ts-common/azure-js-dev-tools";
import { BlobStorageBlob, BlobStoragePrefix, CompressionResult, Compressor, deleteFile, FakeGitHub, getChildFilePaths, getCompositeLogger, getGitHubRepository, getRepositoryFullName, gitCheckout, GitHub, GitHubComment, GitHubRepository, HttpResponse, joinPath, npmInstall, npmPack, run, Runner, RunOptions, RunResult, URLBuilder } from "@ts-common/azure-js-dev-tools";
import { getLines } from "@ts-common/azure-js-dev-tools/dist/lib/common";
import * as path from "path";

/**
 * Options that can be used within a package command.
 */
export interface PackageCommandOptions extends RunOptions {
  /**
   * The path to the package folder.
   */
  packageFolderPath: string;
  /**
   * The Compressor that can be used to create archives.
   */
  compressor: Compressor;
  /**
   * The Runner that will be used to run external process commands.
   */
  runner: Runner | undefined;
  /**
   * A function that will be used to write logs.
   */
  log: (text: string) => Promise<any> | any;
  /**
   * Whether or not to write the command that will be executed to the console. Defaults to true.
   */
  showCommand: boolean | undefined;
}

/**
 * A configuration for how to interact with repositories in a specific programming language.
 */
export interface LanguageConfiguration {
  /**
   * The name of the programming language.
   */
  name: string;
  /**
   * Aliases that the programming language may also be known by.
   */
  aliases?: string[];
  /**
   * The name of a file that is found at the root of a generated package for this language.
   */
  packageRootFileName?: string;
  /**
   * The commands that should be run to create a package for this language.
   */
  packageCommands?: (((options: PackageCommandOptions) => Promise<any>) | string)[];
  /**
   * The file extension of a package file.
   */
  packageFileExtension?: string;
}

/**
 * A language configuration for JavaScript-based languages.
 */
export const javascript: LanguageConfiguration = {
  name: "JavaScript",
  aliases: ["TypeScript", "TS", "JS", "Node", "Nodejs", "Node.js"],
  packageRootFileName: "package.json",
  packageCommands: [
    options => npmPack({
      ...options,
      executionFolderPath: options.packageFolderPath
    })
  ],
  packageFileExtension: ".tgz"
};

export const python: LanguageConfiguration = {
  name: "Python",
  packageRootFileName: "setup.py"
};

export const csharp: LanguageConfiguration = {
  name: "C#",
  aliases: ["CSharp", "C-Sharp", "CS"]
};

export const ruby: LanguageConfiguration = {
  name: "Ruby"
};

export const go: LanguageConfiguration = {
  name: "Go"
};

export const java: LanguageConfiguration = {
  name: "Java",
  packageRootFileName: "pom.xml"
};

export interface AdvancedOptions {
  /**
   * Add more layers of folders to clone the repo, if necessary. Right now, useful for Go only.
   * "sdkrel:" will consider this as the final folder path.
   */
  clone_dir?: string;
  /**
   * An optional list of files/directory to keep when we generate new SDK. This support a
   * Bash-like wildcard syntax (i.e. "my*file.py"). This applies to every Swagger files.
   */
  wrapper_filesOrDirs?: string[];
  /**
   * An optional list of files/directory to delete from the generated SDK. This support a
   * Bash-like wildcard syntax (i.e. "my*file.py") This applies to every Swagger files.
   */
  delete_filesOrDirs?: string[];
  /**
   * If the data to consider generated by Autorest are not directly in the root folder. For
   * instance, if Autorest generates a networkclient folder and you want to consider this folder as
   * the root of data. This parameter is applied before 'delete_filesOrDirs', consider it in your
   * paths. This applies to every Swagger files.
   */
  generated_relative_base_directory?: string;
  /**
   * This is the folder in your SDK repository where you want to put the generated files.
   */
  output_dir?: string;
  /**
   * This is an optional folder where to put metadata about the generation (Autorest version, date
   * of generation, etc.). This can be used by our monitoring system to detect package that needs an
   * update. Be sure this folder is unique in the entire file, to avoid overwritting a file from
   * another project.
   */
  build_dir?: string;
}

/**
 * A set of options for giving specific properties to certain service/resource providers.
 */
export interface Project {
  /**
   * This is an optional parameter which specificy the Autorest MD file path for this project. This
   * is relative to the rest-folder paramter.
   */
  markdown?: string;
  /**
   * An optional dictionary of options you want to pass to Autorest. This will be passed in any
   * call, but can be override by "autorest_options" in each data. Note that you CAN'T override
   * "--output-folder" which is filled contextually. All options prefixed by "sdkrel:" can be a
   * relative path that will be solved against SDK folder before being sent to Autorest.
   */
  autorest_options?: jsDevTools.AutoRestOptions;
  /**
   * An optional list of files/directory to keep when we generate new SDK. This support a
   * Bash-like wildcard syntax (i.e. "my*file.py"). This applies to every Swagger files.
   */
  wrapper_filesOrDirs?: string[];
  /**
   * An optional list of files/directory to delete from the generated SDK. This support a
   * Bash-like wildcard syntax (i.e. "my*file.py") This applies to every Swagger files.
   */
  delete_filesOrDirs?: string[];
  /**
   * If the data to consider generated by Autorest are not directly in the root folder. For
   * instance, if Autorest generates a networkclient folder and you want to consider this folder
   * as the root of data. This parameter is applied before 'delete_filesOrDirs', consider it in
   * your paths. This applies to every Swagger files.
   */
  generated_relative_base_directory?: string;
  /**
   * This is the folder in your SDK repository where you want to put the generated files.
   */
  output_dir?: string;
  /**
   * This is an optional folder where to put metadata about the generation (Autorest version, date
   * of generation, etc.). This can be used by our monitoring system to detect package that needs an
   * update. Be sure this folder is unique in the entire file, to avoid overwritting a file from
   * another project.
   */
  build_dir?: string;
}

/**
 * A configuration that describes how SwaggerToSDK should behave for a specific repository.
 */
export interface SwaggerToSDKConfiguration {
  meta?: {
    /**
     * The version of SwaggerToSDK to use.
     * The version must be 0.2.0.
     */
    version?: string;
    /**
     * List of commands to execute after the generation is done. Will be executed in the order of the
     * list. Current working directory will be the cloned path. See also "envs" node.
     */
    after_scripts?: string[];
    /**
     * The version of autorest to use. Defaults to the latest published version.
     */
    autorest_version?: string;
    /**
     * An optional dictionary of options you want to pass to Autorest. This will be passed in any
     * call, but can be override by "autorest_options" in each data. Note that you CAN'T override
     * "--output-folder" which is filled contextually. All options prefixed by "sdkrel:" can be a
     * relative path that will be solved against SDK folder before being sent to Autorest.
     */
    autorest_options?: jsDevTools.AutoRestOptions;
    /**
     * Environment variables for after_scripts. All options prefixed by "sdkrel:" can be a relative
     * path that will be resolved against SDK folder before being sent to the scripts.
     */
    envs?: jsDevTools.StringMap<string | boolean | number>;
    advanced_options?: AdvancedOptions;
    /**
     * An optional list of files/directory to keep when we generate new SDK. This support a
     * Bash-like wildcard syntax (i.e. "my*file.py"). This applies to every Swagger files.
     */
    wrapper_filesOrDirs?: string[];
    /**
     * An optional list of files/directory to delete from the generated SDK. This support a
     * Bash-like wildcard syntax (i.e. "my*file.py") This applies to every Swagger files.
     */
    delete_filesOrDirs?: string[];
    /**
     * If the data to consider generated by Autorest are not directly in the root folder. For
     * instance, if Autorest generates a networkclient folder and you want to consider this folder
     * as the root of data. This parameter is applied before 'delete_filesOrDirs', consider it in
     * your paths. This applies to every Swagger files.
     */
    generated_relative_base_directory?: string;
    /**
     * A file that marks the root of a package. In Node.js this is package.json. In Python it's
     * setup.py.
     */
    package_root_file?: string;
  };
  /**
   * It's a dict where keys are a project id. The project id has no constraint, but it's recommended
   * to use namespace style, like "datalake.store.account" to provide the best flexibility for the
   * --project parameter.
   */
  projects?: jsDevTools.StringMap<Project>;
}

/**
 * Options that can be provided when creating a new SwaggerToSDK object.
 */
export interface SwaggerToSDKOptions {
  /**
   * The logger object that SwaggerToSDK will use. Defaults to InMemoryLogger.
   */
  logger?: jsDevTools.Logger;
  /**
   * The client that will be used to send HTTP requests.
   */
  httpClient?: jsDevTools.HttpClient;
  /**
   * The runner object that will be used to execute external-process commands.
   */
  runner?: jsDevTools.Runner;
  /**
   * A factory function that will be used to create a Compressor used to compress folders for
   * uploading.
   */
  compressorCreator?: () => jsDevTools.Compressor;
  /**
   * The languages that have been configured.
   */
  languages?: LanguageConfiguration[] | ((defaultLanguages: LanguageConfiguration[]) => LanguageConfiguration[]);
  /**
   * The GitHub object that SwaggerToSDK will use to create and update comments and to create pull
   * requests.
   */
  github?: GitHub;
}

/**
 * Options that can be provided to the SwaggerToSDK.pullRequestChange() function.
 */
export interface SwaggerToSDKPullRequestChangeOptions {
  /**
   * The folder where SwaggerToSDK can create folders and clone repositories to. If this isn't
   * defined, then the current working directory will be used.
   */
  workingFolderPath?: string;
  /**
   * Whether or not to delete the locally cloned repositories used for generation. Defaults to true.
   */
  deleteClonedRepositories?: boolean;
  /**
   * Whether or not to compress and upload the cloned repositories after AutoRest has been run.
   * Defaults to false.
   */
  uploadClonedRepositories?: boolean;
  /**
   * Whether or not to log verbose logs.
   */
  logVerbose?: boolean;
}

/**
 * The regular expression used to get a relative file path from a pull request diff_url contents
 * line.
 */
const diffGitLineRegex: RegExp = /diff --git a\/(.*) b\/.*/;

async function createTempFolder(baseFolderPath: string): Promise<string> {
  let count = 1;
  let workingFolderPath: string = jsDevTools.joinPath(baseFolderPath, count.toString());
  while (!await jsDevTools.createFolder(workingFolderPath)) {
    ++count;
    workingFolderPath = jsDevTools.joinPath(baseFolderPath, count.toString());
  }
  return workingFolderPath;
}

export async function getWorkingFolderPath(baseWorkingFolderPath: string | undefined): Promise<string> {
  const customBaseWorkingFolderPath: boolean = !!baseWorkingFolderPath;
  if (!baseWorkingFolderPath) {
    baseWorkingFolderPath = process.cwd();
  } else if (!jsDevTools.isRooted(baseWorkingFolderPath)) {
    baseWorkingFolderPath = jsDevTools.joinPath(process.cwd(), baseWorkingFolderPath);
  }

  let workingFolderPath: string;
  try {
    workingFolderPath = await createTempFolder(baseWorkingFolderPath);
  } catch (error) {
    if (!customBaseWorkingFolderPath) {
      throw error;
    } else {
      // Error when trying to create the working folder path. Fall back to creating a temporary
      // folder in the current working directory.
      workingFolderPath = await createTempFolder(process.cwd());
    }
  }

  return workingFolderPath;
}

export function getRepositoryFolderPath(generationInstanceFolderPath: string, swaggerToSDKConfig: SwaggerToSDKConfiguration, repositoryNumber: number): string {
  let repositoryFolderPath = `${generationInstanceFolderPath}`;
  if (swaggerToSDKConfig.meta &&
    swaggerToSDKConfig.meta.advanced_options &&
    swaggerToSDKConfig.meta.advanced_options.clone_dir) {
    repositoryFolderPath = jsDevTools.joinPath(repositoryFolderPath, swaggerToSDKConfig.meta.advanced_options.clone_dir);
  } else {
    repositoryFolderPath = jsDevTools.joinPath(repositoryFolderPath, repositoryNumber.toString());
  }
  return repositoryFolderPath;
}

async function logInterestingFiles(files: string[] | undefined, logger: jsDevTools.Logger, fileChange: string): Promise<void> {
  if (files && files.length > 0) {
    await logger.logInfo(`The following files were ${fileChange}:`);
    for (const file of files) {
      await logger.logInfo(`  ${file}`);
    }
  }
}

export function getBlobLogger(blob: jsDevTools.BlobStorageBlob): jsDevTools.Logger {
  const logs: string[] = [];
  function log(text: string): Promise<void> {
    logs.push(text);
    return blob.setContentsFromString(logs.join("\n"), {
      contentType: "text/plain"
    });
  }
  return {
    logInfo: log,
    logError: log,
    logWarning: log,
    logSection: log,
    logVerbose: log,
  };
}

/**
 * The name of the BlobStorage container that will store details about a request that came from a
 * changed pull request.
 */
export const pullRequestsContainerName = "pullrequests";

export const logsFileName = "logs.txt";

/**
 * The collection of functions that implement the Swagger To SDK service.
 */
export class SwaggerToSDK {
  public readonly workingPrefix: jsDevTools.BlobStoragePrefix;
  public readonly logger: jsDevTools.Logger | undefined;
  public readonly httpClient: jsDevTools.HttpClient;
  public readonly runner: jsDevTools.Runner | undefined;
  public readonly compressorCreator: () => jsDevTools.Compressor;
  public readonly languages: LanguageConfiguration[];
  public readonly github: GitHub;

  constructor(workingPrefix: jsDevTools.BlobStoragePrefix, options?: SwaggerToSDKOptions) {
    options = options || {};
    this.workingPrefix = workingPrefix;
    this.logger = options.logger;
    this.httpClient = options.httpClient || new jsDevTools.NodeHttpClient();
    this.runner = options.runner;
    this.compressorCreator = options.compressorCreator || (() => new jsDevTools.ArchiverCompressor());

    if (Array.isArray(options.languages)) {
      this.languages = options.languages;
    } else {
      const defaultLanguages: LanguageConfiguration[] = [
        csharp,
        go,
        java,
        javascript,
        python,
        ruby
      ];
      if (options.languages) {
        this.languages = options.languages(defaultLanguages);
      } else {
        this.languages = defaultLanguages;
      }
    }

    this.github = options.github || new FakeGitHub();
  }

  private getPullRequestPrefix(repository: jsDevTools.GitHubRepository, pullRequestNumber: number): jsDevTools.BlobStoragePrefix {
    return this.workingPrefix
      .getPrefix(jsDevTools.getRepositoryFullName(repository) + "/")
      .getPrefix(pullRequestNumber.toString() + "/");
  }

  private getGenerationInstancePrefix(repository: jsDevTools.GitHubRepository, pullRequestNumber: number, generationInstance: number): jsDevTools.BlobStoragePrefix {
    return this.getPullRequestPrefix(repository, pullRequestNumber)
      .getPrefix(generationInstance.toString() + "/");
  }

  private getRepositoryFileName(repository: GitHubRepository, extension: string): string {
    if (!extension.startsWith(".")) {
      extension = `.${extension}`;
    }
    return `${getRepositoryFullName(repository).toLowerCase().replace("/", ".")}${extension}`;
  }

  private async createGenerationInstance(repository: jsDevTools.GitHubRepository, pullRequestNumber: number): Promise<number> {
    // Create the working prefix's container if it doesn't already exist.
    await this.workingPrefix.getContainer().create({
      accessPolicy: "blob"
    });

    let generationInstance = 1;
    let generationInstancePrefix: BlobStoragePrefix = this.getGenerationInstancePrefix(repository, pullRequestNumber, generationInstance);
    while (!await generationInstancePrefix.getBlob(logsFileName).create()) {
      ++generationInstance;
      generationInstancePrefix = this.getGenerationInstancePrefix(repository, pullRequestNumber, generationInstance);
    }

    return generationInstance;
  }

  /**
   * Get the registered LanguageConfiguration for the provided GitHub repository.
   * @param repository The repository to get a LanguageConfiguration for.
   */
  private getLanguageForRepository(repository: GitHubRepository): LanguageConfiguration | undefined {
    const lowerCasedRepositoryFullName: string = jsDevTools.getRepositoryFullName(repository).toLowerCase();
    return jsDevTools.first(this.languages, (language: LanguageConfiguration) => {
      let matches: boolean = (lowerCasedRepositoryFullName.indexOf(language.name.toLowerCase()) !== -1);
      if (!matches && language.aliases) {
        for (const alias of language.aliases) {
          matches = lowerCasedRepositoryFullName.indexOf(alias.toLowerCase()) !== -1;
          if (matches) {
            break;
          }
        }
      }
      return matches;
    });
  }

  /**
   * The implementation-independent function that gets called when GitHub invokes a pull request webhook request to our tooling service.
   * @param pullRequestChangeBody The body of the GitHub pull request webhook request.
   */
  public async pullRequestChange(pullRequestChangeBody: jsDevTools.GitHubPullRequestWebhookBody, options?: SwaggerToSDKPullRequestChangeOptions): Promise<void> {
    options = options || {};

    const github: GitHub = this.github;

    const deleteWorkingFolder: boolean = options.deleteClonedRepositories != undefined ? options.deleteClonedRepositories : true;

    const apiPullRequest: jsDevTools.GitHubPullRequest = pullRequestChangeBody.pull_request;

    const pullRequestRepository: jsDevTools.GitHubRepository = jsDevTools.getGitHubRepository("Azure/azure-rest-api-specs");
    const pullRequestRepositoryFullName: string = getRepositoryFullName(pullRequestRepository);
    const pullRequestNumber: number = apiPullRequest.number;
    const generationInstance: number = await this.createGenerationInstance(pullRequestRepository, pullRequestNumber);
    const previousGenerationInstance: number = generationInstance - 1;
    const nextGenerationInstance: number = generationInstance + 1;

    const workingFolderPath: string = await getWorkingFolderPath(options.workingFolderPath);
    const pullRequestPrefix: BlobStoragePrefix = this.getPullRequestPrefix(pullRequestRepository, pullRequestNumber);

    const generationInstancePrefix: BlobStoragePrefix = pullRequestPrefix.getPrefix(generationInstance.toString() + "/");
    const previousGenerationInstancePrefix: BlobStoragePrefix = pullRequestPrefix.getPrefix(previousGenerationInstance.toString() + "/");
    const nextGenerationInstancePrefix: BlobStoragePrefix = pullRequestPrefix.getPrefix(nextGenerationInstance.toString() + "/");
    const logsBlob: jsDevTools.BlobStorageBlob = generationInstancePrefix.getBlob(logsFileName);
    let logger: jsDevTools.Logger = jsDevTools.wrapLogger(getBlobLogger(logsBlob), { logVerbose: !!options.logVerbose });
    if (this.logger) {
      logger = jsDevTools.getCompositeLogger(logger, this.logger);
    }
    try {
      await logger.logSection(`Received pull request change webhook request from GitHub for "${apiPullRequest.html_url}".`);

      const generationBlob: BlobStorageBlob = generationInstancePrefix.getBlob("generation.json");
      const previousGenerationBlob: BlobStorageBlob = previousGenerationInstancePrefix.getBlob("generation.json");
      const nextGenerationBlob: BlobStorageBlob = nextGenerationInstancePrefix.getBlob("generation.json");

      await logger.logSection(`Getting generation state from ${URLBuilder.parse(previousGenerationBlob.getURL()).setQuery(undefined).toString()}...`);

      const generationHtmlBlob: BlobStorageBlob = generationInstancePrefix.getBlob("generation.html");

      async function postGenerationStateToBlobs(generation: Generation, generationHTML: string): Promise<any> {
        return Promise.all([
          writeGenerationToBlob(generationBlob, generation),
          generationHtmlBlob.setContentsFromString(generationHTML, { contentType: "text/html" })
        ]);
      }

      const generation: Generation = await previousGenerationBlob.getContentsAsString()
        .then(async (previousGenerationBlobContent: string | undefined) => {
          let previousGenerationCommentIdPromise: Promise<number>;
          if (previousGenerationBlobContent) {
            try {
              const previousGeneration: Generation = JSON.parse(previousGenerationBlobContent);
              previousGenerationCommentIdPromise = Promise.resolve(previousGeneration.commentId);
            } catch (error) {
              const errorMessage = `Failed to parse generation blob content: ${JSON.stringify(error)}`;
              await logger.logError(errorMessage);
              previousGenerationCommentIdPromise = Promise.reject(error);
            }
          } else {
            const errorMessage = "Generation blob didn't have any content.";
            await logger.logError(errorMessage);
            previousGenerationCommentIdPromise = Promise.reject(new Error(errorMessage));
          }
          return previousGenerationCommentIdPromise;
        })
        .catch(async () => {
          const newCommentText: string = getGenerationHTML().join("");
          const newComment: GitHubComment = await github.createPullRequestComment(pullRequestRepository, pullRequestNumber, newCommentText);
          return newComment.id;
        })
        .then(async (commentId: number) => {
          const newGeneration: Generation = {
            pullRequestRepositoryFullName,
            pullRequestNumber,
            commentId,
            logsBlobUrl: URLBuilder.parse(logsBlob.getURL()).setQuery(undefined).toString(),
            repositories: {}
          };
          await postGenerationStateToBlobs(newGeneration, getGenerationHTML(newGeneration).join(""));
          return newGeneration;
        });

      async function postGenerationState(generation: Generation): Promise<any> {
        const generationHTML: string = getGenerationHTML(generation).join("");

        const resultPromises: Promise<any>[] = [];

        resultPromises.push(postGenerationStateToBlobs(generation, generationHTML));

        if (await nextGenerationBlob.exists()) {
          resultPromises.push(github.updatePullRequestComment(pullRequestRepository, pullRequestNumber, generation.commentId, generationHTML));
        }

        return Promise.all(resultPromises);
      }

      await logger.logSection(`Getting diff_url (${apiPullRequest.diff_url}) contents...`);
      const diffUrlResponse: jsDevTools.HttpResponse = await this.httpClient.sendRequest({ method: "GET", url: apiPullRequest.diff_url });
      const statusCodeMessage = `diff_url response status code is ${diffUrlResponse.statusCode}.`;
      if (diffUrlResponse.statusCode !== 200) {
        await logger.logError(statusCodeMessage);
      } else {
        await logger.logInfo(statusCodeMessage);
        if (!diffUrlResponse.body) {
          await logger.logError(`diff_url response body is empty.`);
        } else {
          const diffUrlResponseBodyLines: string[] = diffUrlResponse.body.split(/\r?\n/);
          await logger.logInfo(`diff_url response body contains ${diffUrlResponseBodyLines.length} lines.`);
          const changedFileDiffLinePrefix = "diff --git";
          const diffGitLines: string[] = jsDevTools.where(diffUrlResponseBodyLines, (line: string) => line.startsWith(changedFileDiffLinePrefix));
          await logger.logInfo(`diff_url response body contains ${diffGitLines.length} "${changedFileDiffLinePrefix}" lines.`);
          const changedFileRelativePaths: string[] = jsDevTools.map(diffGitLines, (line: string) => line.match(diffGitLineRegex)![1]);
          await logger.logInfo(`diff_url response body contains ${changedFileRelativePaths.length} changed files:`);
          for (const changedFileRelativePath of changedFileRelativePaths) {
            await logger.logInfo(changedFileRelativePath);
          }
          const specificationChangedFileRelativePaths: string[] = jsDevTools.where(changedFileRelativePaths, (text: string) => text.startsWith("specification/"));
          await logger.logInfo(`diff_url response body contains ${specificationChangedFileRelativePaths.length} changed files in the specification folder:`);
          for (const changedFileRelativePath of specificationChangedFileRelativePaths) {
            await logger.logInfo(changedFileRelativePath);
          }
          const readmeMdRelativeFilePathsToGenerate: string[] = [];
          for (const changedFileRelativePath of specificationChangedFileRelativePaths) {
            let searchString = "/resource-manager/";
            let searchStringIndex: number = changedFileRelativePath.indexOf(searchString);
            if (searchStringIndex === -1) {
              searchString = "/data-plane/";
              searchStringIndex = changedFileRelativePath.indexOf(searchString);
            }

            if (searchStringIndex !== -1) {
              const readmeMdRelativeFilePath = changedFileRelativePath.substr(0, searchStringIndex + searchString.length) + "readme.md";
              if (readmeMdRelativeFilePathsToGenerate.indexOf(readmeMdRelativeFilePath) === -1) {
                readmeMdRelativeFilePathsToGenerate.push(readmeMdRelativeFilePath);
              }
            }
          }
          await logger.logInfo(`Found ${readmeMdRelativeFilePathsToGenerate.length} readme.md files to generate:`);
          for (const readmeMdRelativeFilePathToGenerate of readmeMdRelativeFilePathsToGenerate) {
            await logger.logInfo(readmeMdRelativeFilePathToGenerate);
          }
          for (const readmeMdRelativeFilePathToGenerate of readmeMdRelativeFilePathsToGenerate) {
            await logger.logSection(`Looking for languages to generate in "${readmeMdRelativeFilePathToGenerate}"...`);
            const mergedReadmeMdFileUrl = `https://raw.githubusercontent.com/azure/azure-rest-api-specs/${apiPullRequest.merge_commit_sha}/${readmeMdRelativeFilePathToGenerate}`;
            await logger.logSection(`Getting file contents for "${mergedReadmeMdFileUrl}"...`);
            const mergedReadmeMdFileResponse: HttpResponse = await this.httpClient.sendRequest({ method: "GET", url: mergedReadmeMdFileUrl });
            await logger.logInfo(`Merged readme.md response status code is ${mergedReadmeMdFileResponse.statusCode}.`);
            const mergedReadmeMdFileContents: string | undefined = mergedReadmeMdFileResponse.body;
            if (!mergedReadmeMdFileContents) {
              await logger.logError(`Merged readme.md response body is empty.`);
            } else {
              const swaggerToSDKConfiguration: jsDevTools.ReadmeMdSwaggerToSDKConfiguration | undefined = jsDevTools.findSwaggerToSDKConfiguration(mergedReadmeMdFileContents);
              if (!swaggerToSDKConfiguration) {
                await logger.logError(`No SwaggerToSDK configuration YAML block found in the merged readme.md.`);
              } else {
                await logger.logInfo(`Found ${swaggerToSDKConfiguration.repositories.length} requested SDK repositories:`);
                for (const requestedRepository of swaggerToSDKConfiguration.repositories) {
                  const repository: GitHubRepository = getGitHubRepository(requestedRepository.repo);
                  if (!repository.organization) {
                    repository.organization = "Azure";
                  }
                  requestedRepository.repo = getRepositoryFullName(repository);
                  await logger.logInfo(requestedRepository.repo);
                  generation.repositories[requestedRepository.repo] = {
                    fullName: requestedRepository.repo,
                    status: "pending"
                  };
                }

                await postGenerationState(generation);

                let repositoryIndex = 0;
                for (const requestedRepository of swaggerToSDKConfiguration.repositories) {
                  const repositoryNumber: number = ++repositoryIndex;
                  const repository: GitHubRepository = getGitHubRepository(requestedRepository.repo);
                  const fullRepositoryName: string = getRepositoryFullName(repository);
                  const repositoryPrefix: jsDevTools.BlobStoragePrefix = generationInstancePrefix.getPrefix(`${fullRepositoryName}/`);
                  const repoLoggerBlob: jsDevTools.BlobStorageBlob = repositoryPrefix.getBlob(logsFileName);
                  const repoLogger: jsDevTools.Logger = getCompositeLogger(logger, jsDevTools.wrapLogger(getBlobLogger(repoLoggerBlob), {
                    logVerbose: !!options.logVerbose
                  }));
                  const repositoryUrl = `https://github.com/${fullRepositoryName}`;
                  await repoLogger.logSection(`Checking if ${repositoryUrl} exists...`);

                  const generationRepository: GenerationRepository = generation.repositories[fullRepositoryName];
                  generationRepository.status = "inProgress";
                  generationRepository.logsBlobUrl = URLBuilder.parse(repoLoggerBlob.getURL()).setQuery(undefined).toString();
                  await postGenerationState(generation);

                  function repoError(errorMessage: string): Promise<any> {
                    generationRepository.status = "failed";
                    return Promise.all([
                      repoLogger.logError(errorMessage),
                      postGenerationState(generation)
                    ]);
                  }

                  const repositoryExistsResponse: HttpResponse = await this.httpClient.sendRequest({ method: "HEAD", url: repositoryUrl });
                  if (repositoryExistsResponse.statusCode !== 200) {
                    await repoError(`Could not find a repository at ${repositoryUrl}.`);
                  } else {
                    const swaggerToSDKConfigFileUrl = `https://raw.githubusercontent.com/${fullRepositoryName}/master/swagger_to_sdk_config.json`;
                    const swaggerToSDKConfigFileResponse: HttpResponse = await this.httpClient.sendRequest({ method: "GET", url: swaggerToSDKConfigFileUrl });
                    if (swaggerToSDKConfigFileResponse.statusCode !== 200) {
                      await repoError(`Could not find a swagger_to_sdk_config.json file at ${swaggerToSDKConfigFileUrl}.`);
                    } else {
                      const swaggerToSDKConfigFileContents: string | undefined = swaggerToSDKConfigFileResponse.body;
                      if (!swaggerToSDKConfigFileContents) {
                        await repoError(`The swagger_to_sdk_config.json file at ${swaggerToSDKConfigFileUrl} is empty.`);
                      } else {
                        const swaggerToSDKConfig: SwaggerToSDKConfiguration = JSON.parse(swaggerToSDKConfigFileContents);
                        if (!swaggerToSDKConfig.meta) {
                          await repoError(`No meta property exists in ${swaggerToSDKConfigFileUrl}.`);
                        } else {
                          const repositoryFolderPath = getRepositoryFolderPath(workingFolderPath, swaggerToSDKConfig, repositoryNumber);
                          const cloneResult: jsDevTools.RunResult = await jsDevTools.gitClone(repositoryUrl, {
                            runner: this.runner,
                            depth: 1,
                            directory: repositoryFolderPath,
                            quiet: true,
                            log: repoLogger.logInfo,
                            showCommand: true
                          });
                          if (cloneResult.exitCode !== 0) {
                            await repoError(`Failed to clone ${repositoryUrl} to ${repositoryFolderPath}:`);
                            if (cloneResult.stdout) {
                              for (const message of getLines(cloneResult.stdout)) {
                                if (message) {
                                  await repoError(message);
                                }
                              }
                            }
                            if (cloneResult.stderr) {
                              for (const errorMessage of getLines(cloneResult.stderr)) {
                                if (errorMessage) {
                                  await repoError(errorMessage);
                                }
                              }
                            }
                            if (cloneResult.error) {
                              await repoError(JSON.stringify(cloneResult.error));
                            }
                          } else {
                            let autorestInstallSource = `autorest`;
                            if (swaggerToSDKConfig.meta.autorest_version) {
                              autorestInstallSource += `@${swaggerToSDKConfig.meta.autorest_version}`;
                            }
                            const installAutorestResult: jsDevTools.RunResult = await npmInstall({
                              runner: this.runner,
                              installSource: autorestInstallSource,
                              executionFolderPath: repositoryFolderPath,
                              showCommand: true,
                              log: repoLogger.logInfo
                            });
                            if (installAutorestResult.exitCode !== 0) {
                              await repoError(`Failed to install ${autorestInstallSource}.`);
                            } else {
                              const autorestOptions: jsDevTools.AutoRestOptions = swaggerToSDKConfig.meta.autorest_options || {};

                              for (const autorestOptionName of Object.keys(autorestOptions)) {
                                const autorestOptionValue: jsDevTools.AutoRestOptionValue = autorestOptions[autorestOptionName];
                                if (autorestOptionName.startsWith("sdkrel:") && typeof autorestOptionValue === "string") {
                                  const resolvedAutorestOptionName: string = autorestOptionName.substring("sdkrel:".length);
                                  const resolvedAutorestOptionValue: string = jsDevTools.joinPath(repositoryFolderPath, autorestOptionValue);
                                  delete autorestOptions[autorestOptionName];
                                  autorestOptions[resolvedAutorestOptionName] = resolvedAutorestOptionValue;
                                }
                              }

                              const autorestResult: jsDevTools.RunResult = await jsDevTools.autorest(mergedReadmeMdFileUrl, autorestOptions, {
                                autorestPath: "./node_modules/.bin/autorest",
                                runner: this.runner,
                                executionFolderPath: repositoryFolderPath,
                                showCommand: true,
                                log: repoLogger.logInfo
                              });

                              const nodeModulesFolderPath: string = jsDevTools.joinPath(repositoryFolderPath, "node_modules");
                              if (jsDevTools.folderExistsSync(nodeModulesFolderPath)) {
                                await repoLogger.logSection(`Deleting folder ${nodeModulesFolderPath}...`);
                                jsDevTools.deleteFolder(nodeModulesFolderPath);
                              }
                              const packageLockJsonFilePath: string = jsDevTools.joinPath(repositoryFolderPath, "package-lock.json");
                              if (jsDevTools.fileExistsSync(packageLockJsonFilePath)) {
                                await repoLogger.logSection(`Deleting file ${packageLockJsonFilePath}...`);
                                jsDevTools.deleteFile(packageLockJsonFilePath);
                              }
                              const packageJsonFilePath: string = jsDevTools.joinPath(repositoryFolderPath, "package.json");
                              if (jsDevTools.fileExistsSync(packageJsonFilePath)) {
                                await repoLogger.logSection(`Resetting file ${packageJsonFilePath}...`);
                                await gitCheckout("package.json", {
                                  runner: this.runner,
                                  executionFolderPath: repositoryFolderPath,
                                  showCommand: true,
                                  log: repoLogger.logInfo
                                });
                              }

                              if (autorestResult.exitCode !== 0) {
                                await repoError(`Failed to run autorest.`);
                              } else {
                                const gitStatusResult: jsDevTools.GitStatusResult = await jsDevTools.gitStatus({
                                  runner: this.runner,
                                  executionFolderPath: repositoryFolderPath,
                                  showCommand: true,
                                  log: repoLogger.logInfo
                                });

                                if (!gitStatusResult.hasUncommittedChanges) {
                                  await repoLogger.logInfo(`No changes were detected after AutoRest ran.`);
                                } else {
                                  await logInterestingFiles(gitStatusResult.untrackedFiles, repoLogger, "added");
                                  await logInterestingFiles(gitStatusResult.notStagedModifiedFiles, repoLogger, "modified");
                                  await logInterestingFiles(gitStatusResult.notStagedDeletedFiles, repoLogger, "deleted");
                                }

                                if (options.uploadClonedRepositories) {
                                  const repositoryZipFileName: string = this.getRepositoryFileName(repository, ".zip");
                                  const repositoryZipFilePath: string = jsDevTools.joinPath(workingFolderPath, repositoryZipFileName);
                                  await repoLogger.logSection(`Compressing ${repositoryFolderPath} to ${repositoryZipFilePath}...`);
                                  const compressor: jsDevTools.Compressor = this.compressorCreator();
                                  const repoFolderCompressionResult: CompressionResult = await compressor.zip(repositoryFolderPath, repositoryZipFilePath);
                                  if (repoFolderCompressionResult.warnings && repoFolderCompressionResult.warnings.length > 0) {
                                    for (const warning of repoFolderCompressionResult.warnings) {
                                      await repoLogger.logWarning(JSON.stringify(warning));
                                    }
                                  }
                                  if (repoFolderCompressionResult.errors && repoFolderCompressionResult.errors.length > 0) {
                                    for (const error of repoFolderCompressionResult.errors) {
                                      await repoError(JSON.stringify(error));
                                    }
                                  }

                                  const repositoryZipBlob: jsDevTools.BlobStorageBlob = repositoryPrefix.getBlob(repositoryZipFileName);
                                  const repositoryZipBlobURLBuilder: URLBuilder = URLBuilder.parse(repositoryZipBlob.getURL());
                                  // Get rid of the SAS in the URL.
                                  repositoryZipBlobURLBuilder.setQuery(undefined);
                                  repoLogger.logSection(`Uploading compressed repository to ${repositoryZipBlobURLBuilder.toString()}...`);
                                  try {
                                    await repositoryZipBlob.setContentsFromFile(repositoryZipFilePath);
                                    repoLogger.logInfo(`  Done uploading compressed repository to ${repositoryZipBlobURLBuilder.toString()}...`);
                                  } finally {
                                    deleteFile(repositoryZipFilePath);
                                  }
                                }

                                const repositoryLanguage: LanguageConfiguration | undefined = this.getLanguageForRepository(repository);
                                if (!repositoryLanguage) {
                                  const languageNames: string[] = jsDevTools.map(this.languages, language => language.name);
                                  await repoError(`No programming language registered ${JSON.stringify(languageNames)} that matches the repository ${fullRepositoryName}.`);
                                } else {
                                  await repoLogger.logInfo(`Repository ${fullRepositoryName} matches programming language ${repositoryLanguage.name}.`);
                                  if (!repositoryLanguage.packageRootFileName) {
                                    await repoLogger.logInfo(`No packageRootFileName property has been specified in the language configuration for ${repositoryLanguage.name}.`);
                                  } else {
                                    const changedPackageFolders: string[] = [];
                                    for (const modifiedFile of gitStatusResult.modifiedFiles) {
                                      const packageRootFilePath: string | undefined = jsDevTools.findFileInPathSync(repositoryLanguage.packageRootFileName, modifiedFile);
                                      if (!packageRootFilePath) {
                                        await repoLogger.logWarning(`No package root file found for modified file ${modifiedFile}.`);
                                      } else {
                                        await repoLogger.logVerbose(`Found package root file ${packageRootFilePath} for modified file ${modifiedFile}.`);
                                        const packageFolderPath: string = jsDevTools.getParentFolderPath(packageRootFilePath);
                                        if (!jsDevTools.contains(changedPackageFolders, packageFolderPath)) {
                                          changedPackageFolders.push(packageFolderPath);
                                        }
                                      }
                                    }
                                    await repoLogger.logInfo(`Found ${changedPackageFolders.length} package folder${changedPackageFolders.length === 1 ? "" : "s"} that changed:`);
                                    for (const changedPackageFolder of changedPackageFolders) {
                                      await repoLogger.logInfo(`  ${changedPackageFolder}`);
                                    }

                                    if (!repositoryLanguage.packageCommands || repositoryLanguage.packageCommands.length === 0) {
                                      await repoLogger.logWarning(`${repositoryLanguage.name} has no registered package commands.`);
                                    } else {
                                      if (!repositoryLanguage.packageFileExtension) {
                                        await repoLogger.logWarning(`${repositoryLanguage.name} has no registered package file extension.`);
                                      }

                                      for (const changedPackageFolder of changedPackageFolders) {
                                        for (const packageCommand of repositoryLanguage.packageCommands) {
                                          let commandResult: Promise<RunResult>;
                                          if (typeof packageCommand === "string") {
                                            const packageCommandArray: string[] = packageCommand.split(" ");
                                            const command: string = packageCommandArray.shift()!;
                                            const args: string[] = packageCommandArray;
                                            commandResult = run(command, args, {
                                              executionFolderPath: changedPackageFolder,
                                              runner: this.runner,
                                              showCommand: true,
                                              showResult: true,
                                              captureOutput: repoLogger.logInfo,
                                              captureError: repoLogger.logInfo,
                                              log: repoLogger.logInfo
                                            });
                                          } else {
                                            commandResult = packageCommand(
                                              {
                                                packageFolderPath: changedPackageFolder,
                                                executionFolderPath: changedPackageFolder,
                                                compressor: this.compressorCreator(),
                                                runner: this.runner,
                                                log: repoLogger.logInfo,
                                                showCommand: true,
                                                showResult: true,
                                                captureOutput: repoLogger.logInfo,
                                                captureError: repoLogger.logInfo,
                                              })
                                              .then(() => { return { exitCode: 0 }; })
                                              .catch((error: Error) => { return { error }; });
                                          }
                                          const packageCommandResult: RunResult = await commandResult;
                                          if (packageCommandResult.exitCode !== 0) {
                                            break;
                                          }
                                        }

                                        if (repositoryLanguage.packageFileExtension) {
                                          const packageFileExtension: string = repositoryLanguage.packageFileExtension;
                                          const packagedFilePaths: string[] | undefined = getChildFilePaths(changedPackageFolder, {
                                            recursive: true,
                                            fileCondition: (filePath: string) => filePath.endsWith(packageFileExtension)
                                          });
                                          if (!packagedFilePaths || packagedFilePaths.length === 0) {
                                            await repoLogger.logWarning(`No package files found in ${changedPackageFolder}.`);
                                          } else {
                                            await repoLogger.logInfo(`Found ${packagedFilePaths.length} package file${packagedFilePaths.length === 1 ? "" : "s"} in ${changedPackageFolder}:`);
                                            for (const packageFilePath of packagedFilePaths) {
                                              await repoLogger.logInfo(`  ${packageFilePath}`);
                                            }

                                            for (const packageFilePath of packagedFilePaths) {
                                              const packageFileName: string = path.basename(packageFilePath);
                                              const packageFileBlob: jsDevTools.BlobStorageBlob = generationInstancePrefix.getBlob(joinPath(fullRepositoryName, packageFileName));
                                              const packageFileBlobUrl: string = URLBuilder.parse(packageFileBlob.getURL()).setQuery(undefined).toString();
                                              await repoLogger.logSection(`Uploading ${packageFilePath} to ${packageFileBlobUrl}...`);
                                              await packageFileBlob.setContentsFromFile(packageFilePath);
                                              await repoLogger.logInfo(`Done uploading ${packageFilePath} to ${packageFileBlobUrl}.`);

                                              generationRepository.packageBlobUrl = packageFileBlobUrl;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }

                          if (generationRepository.status === "inProgress") {
                            generationRepository.status = "succeeded";
                            await postGenerationState(generation);
                          }

                          if (!deleteWorkingFolder) {
                            await repoLogger.logInfo(`Not deleting clone of ${fullRepositoryName} at folder ${repositoryFolderPath}.`);
                          } else {
                            await repoLogger.logSection(`Deleting clone of ${fullRepositoryName} at folder ${repositoryFolderPath}...`);
                            jsDevTools.deleteFolder(repositoryFolderPath);
                            await repoLogger.logInfo(`Finished deleting clone of ${fullRepositoryName} at folder ${repositoryFolderPath}.`);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } finally {
      if (!deleteWorkingFolder) {
        await logger.logInfo(`Not deleting working folder ${workingFolderPath}.`);
      } else {
        await logger.logSection(`Deleting working folder ${workingFolderPath}...`);
        jsDevTools.deleteFolder(workingFolderPath);
        await logger.logInfo(`Finished deleting working folder ${workingFolderPath}.`);
      }
    }
  }
}

function writeGenerationToBlob(blob: BlobStorageBlob, generation: Generation): Promise<any> {
  return blob.setContentsFromString(
    JSON.stringify(generation, undefined, 2),
    { contentType: "text/json" });
}

export interface Generation {
  pullRequestRepositoryFullName: string;
  pullRequestNumber: number;
  commentId: number;
  logsBlobUrl: string;
  repositories: jsDevTools.StringMap<GenerationRepository>;
}

export const generationStatus = {
  pending: `Pending`,
  inProgress: `In-Progress`,
  failed: `Failed`,
  succeeded: `Succeeded`
};

export interface GenerationRepository {
  fullName: string;
  status: keyof typeof generationStatus;
  logsBlobUrl?: string;
  packageBlobUrl?: string;
  pullRequestUrl?: string;
}

export function getRepositoryHTML(repositoryFullName: string): string {
  return `<a href="https://github.com/${repositoryFullName}">${repositoryFullName}</a>`;
}

export function getGenerationStatusHTML(status: keyof typeof generationStatus): string {
  return generationStatus[status];
}

export function getLogsHTML(logsBlobUrl: string | undefined): string {
  let result = `Logs`;
  if (logsBlobUrl) {
    result = `<a href="${logsBlobUrl}">${result}</a>`;
  }
  return result;
}

export function getPackageHTML(packageBlobUrl: string | undefined): string {
  let result = `Package`;
  if (packageBlobUrl) {
    result = `<a href="${packageBlobUrl}">${result}</a>`;
  }
  return result;
}

export function getPullRequestHTML(pullRequestUrl: string | undefined): string {
  let result = `Pull Request`;
  if (pullRequestUrl) {
    result = `<a href="${pullRequestUrl}">${result}</a>`;
  }
  return result;
}

/**
 * Get the HTML that describes the current state of a generation.
 * @param generation The current state of a generation.
 */
export function getGenerationHTML(generation?: Generation): string[] {
  const result: string[] = [];
  result.push(`<html>`);
  result.push(`<body>`);
  result.push(`<h1>Generation Progress</h1>`);
  if (generation) {
    result.push(`<a href="${generation.logsBlobUrl}">Generation Logs</a>`);
    if (generation.repositories) {
      const repositoryFullNames: string[] = Object.keys(generation.repositories);
      if (repositoryFullNames && repositoryFullNames.length > 0) {
        result.push(`<table>`);
        for (const repositoryFullName of repositoryFullNames) {
          const generationRepository: GenerationRepository = generation.repositories[repositoryFullName];
          result.push(`<tr>`);
          result.push(`<td>${getRepositoryHTML(generationRepository.fullName)}</td>`);
          result.push(`<td>${getGenerationStatusHTML(generationRepository.status)}</td>`);
          result.push(`<td>${getLogsHTML(generationRepository.logsBlobUrl)}</td>`);
          result.push(`<td>${getPackageHTML(generationRepository.packageBlobUrl)}</td>`);
          result.push(`<td>${getPullRequestHTML(generationRepository.pullRequestUrl)}</td>`);
          result.push(`</tr>`);
        }
        result.push(`</table>`);
      }
    }
  }
  result.push(`</body>`);
  result.push(`</html>`);
  return result;
}
