import * as jsDevTools from "@ts-common/azure-js-dev-tools";
import { BlobStoragePrefix, getCompositeLogger, getGitHubRepository, getRepositoryFullName, gitCheckout, GitHubRepository, HttpResponse, npmInstall } from "@ts-common/azure-js-dev-tools";

export interface AdvancedOptions {
  /**
   * Add more layers of folders to clone the repo, if necessary. Right now, useful for Go only.
   * "sdkrel:" will consider this as the final folder path.
   */
  clone_dir?: string;
  /**
   * An optional list of files/directory to keep when we generate new SDK. This support a
   * Bash-like wildcard syntax (i.e. "my*file.py"). This applies to every Swagger files.
   */
  wrapper_filesOrDirs?: string[];
  /**
   * An optional list of files/directory to delete from the generated SDK. This support a
   * Bash-like wildcard syntax (i.e. "my*file.py") This applies to every Swagger files.
   */
  delete_filesOrDirs?: string[];
  /**
   * If the data to consider generated by Autorest are not directly in the root folder. For
   * instance, if Autorest generates a networkclient folder and you want to consider this folder as
   * the root of data. This parameter is applied before 'delete_filesOrDirs', consider it in your
   * paths. This applies to every Swagger files.
   */
  generated_relative_base_directory?: string;
  /**
   * This is the folder in your SDK repository where you want to put the generated files.
   */
  output_dir?: string;
  /**
   * This is an optional folder where to put metadata about the generation (Autorest version, date
   * of generation, etc.). This can be used by our monitoring system to detect package that needs an
   * update. Be sure this folder is unique in the entire file, to avoid overwritting a file from
   * another project.
   */
  build_dir?: string;
}

/**
 * A set of options for giving specific properties to certain service/resource providers.
 */
export interface Project {
  /**
   * This is an optional parameter which specificy the Autorest MD file path for this project. This
   * is relative to the rest-folder paramter.
   */
  markdown?: string;
  /**
   * An optional dictionary of options you want to pass to Autorest. This will be passed in any
   * call, but can be override by "autorest_options" in each data. Note that you CAN'T override
   * "--output-folder" which is filled contextually. All options prefixed by "sdkrel:" can be a
   * relative path that will be solved against SDK folder before being sent to Autorest.
   */
  autorest_options?: jsDevTools.AutoRestOptions;
  /**
   * An optional list of files/directory to keep when we generate new SDK. This support a
   * Bash-like wildcard syntax (i.e. "my*file.py"). This applies to every Swagger files.
   */
  wrapper_filesOrDirs?: string[];
  /**
   * An optional list of files/directory to delete from the generated SDK. This support a
   * Bash-like wildcard syntax (i.e. "my*file.py") This applies to every Swagger files.
   */
  delete_filesOrDirs?: string[];
  /**
   * If the data to consider generated by Autorest are not directly in the root folder. For
   * instance, if Autorest generates a networkclient folder and you want to consider this folder
   * as the root of data. This parameter is applied before 'delete_filesOrDirs', consider it in
   * your paths. This applies to every Swagger files.
   */
  generated_relative_base_directory?: string;
  /**
   * This is the folder in your SDK repository where you want to put the generated files.
   */
  output_dir?: string;
  /**
   * This is an optional folder where to put metadata about the generation (Autorest version, date
   * of generation, etc.). This can be used by our monitoring system to detect package that needs an
   * update. Be sure this folder is unique in the entire file, to avoid overwritting a file from
   * another project.
   */
  build_dir?: string;
}

/**
 * A configuration that describes how SwaggerToSDK should behave for a specific repository.
 */
export interface SwaggerToSDKConfiguration {
  meta?: {
    /**
     * The version of SwaggerToSDK to use.
     * The version must be 0.2.0.
     */
    version?: string;
    /**
     * List of commands to execute after the generation is done. Will be executed in the order of the
     * list. Current working directory will be the cloned path. See also "envs" node.
     */
    after_scripts?: string[];
    /**
     * The version of autorest to use. Defaults to the latest published version.
     */
    autorest_version?: string;
    /**
     * An optional dictionary of options you want to pass to Autorest. This will be passed in any
     * call, but can be override by "autorest_options" in each data. Note that you CAN'T override
     * "--output-folder" which is filled contextually. All options prefixed by "sdkrel:" can be a
     * relative path that will be solved against SDK folder before being sent to Autorest.
     */
    autorest_options?: jsDevTools.AutoRestOptions;
    /**
     * Environment variables for after_scripts. All options prefixed by "sdkrel:" can be a relative
     * path that will be resolved against SDK folder before being sent to the scripts.
     */
    envs?: jsDevTools.StringMap<string | boolean | number>;
    advanced_options?: AdvancedOptions;
    /**
     * An optional list of files/directory to keep when we generate new SDK. This support a
     * Bash-like wildcard syntax (i.e. "my*file.py"). This applies to every Swagger files.
     */
    wrapper_filesOrDirs?: string[];
    /**
     * An optional list of files/directory to delete from the generated SDK. This support a
     * Bash-like wildcard syntax (i.e. "my*file.py") This applies to every Swagger files.
     */
    delete_filesOrDirs?: string[];
    /**
     * If the data to consider generated by Autorest are not directly in the root folder. For
     * instance, if Autorest generates a networkclient folder and you want to consider this folder
     * as the root of data. This parameter is applied before 'delete_filesOrDirs', consider it in
     * your paths. This applies to every Swagger files.
     */
    generated_relative_base_directory?: string;
    /**
     * A file that marks the root of a package. In Node.js this is package.json. In Python it's
     * setup.py.
     */
    package_root_file?: string;
  };
  /**
   * It's a dict where keys are a project id. The project id has no constraint, but it's recommended
   * to use namespace style, like "datalake.store.account" to provide the best flexibility for the
   * --project parameter.
   */
  projects?: jsDevTools.StringMap<Project>;
}

/**
 * Options that can be provided when creating a new SwaggerToSDK object.
 */
export interface SwaggerToSDKOptions {
  /**
   * The logger object that SwaggerToSDK will use. Defaults to InMemoryLogger.
   */
  logger?: jsDevTools.Logger;
  /**
   * The client that will be used to send HTTP requests.
   */
  httpClient?: jsDevTools.HttpClient;
  /**
   * The runner object that will be used to execute external-process commands.
   */
  runner?: jsDevTools.Runner;
}

/**
 * Options that can be provided to the SwaggerToSDK.pullRequestChange() function.
 */
export interface SwaggerToSDKPullRequestChangeOptions {
  /**
   * The folder where SwaggerToSDK can create folders and clone repositories to. If this isn't
   * defined, then the current working directory will be used.
   */
  workingFolderPath?: string;
  /**
   * Whether or not to delete the locally cloned repositories used for generation. Defaults to true.
   */
  deleteClonedRepositories?: boolean;
}

/**
 * The regular expression used to get a relative file path from a pull request diff_url contents
 * line.
 */
const diffGitLineRegex: RegExp = /diff --git a\/(.*) b\/.*/;

async function createTempFolder(baseFolderPath: string): Promise<string> {
  let count = 1;
  let workingFolderPath: string = jsDevTools.joinPath(baseFolderPath, count.toString());
  while (!await jsDevTools.createFolder(workingFolderPath)) {
    ++count;
    workingFolderPath = jsDevTools.joinPath(baseFolderPath, count.toString());
  }
  return workingFolderPath;
}

export async function getWorkingFolderPath(baseWorkingFolderPath: string | undefined): Promise<string> {
  const customBaseWorkingFolderPath: boolean = !!baseWorkingFolderPath;
  if (!baseWorkingFolderPath) {
    baseWorkingFolderPath = process.cwd();
  } else if (!jsDevTools.isRooted(baseWorkingFolderPath)) {
    baseWorkingFolderPath = jsDevTools.joinPath(process.cwd(), baseWorkingFolderPath);
  }

  let workingFolderPath: string;
  try {
    workingFolderPath = await createTempFolder(baseWorkingFolderPath);
  } catch (error) {
    if (!customBaseWorkingFolderPath) {
      throw error;
    } else {
      // Error when trying to create the working folder path. Fall back to creating a temporary
      // folder in the current working directory.
      workingFolderPath = await createTempFolder(process.cwd());
    }
  }

  return workingFolderPath;
}

export function getRepositoryFolderPath(generationInstanceFolderPath: string, swaggerToSDKConfig: SwaggerToSDKConfiguration): string {
  let repositoryFolderPath = `${generationInstanceFolderPath}`;
  if (swaggerToSDKConfig.meta &&
    swaggerToSDKConfig.meta.advanced_options &&
    swaggerToSDKConfig.meta.advanced_options.clone_dir) {
    repositoryFolderPath = jsDevTools.joinPath(repositoryFolderPath, swaggerToSDKConfig.meta.advanced_options.clone_dir);
  } else {
    let repositoryNumber = 1;
    while (jsDevTools.folderExistsSync(jsDevTools.joinPath(repositoryFolderPath, repositoryNumber.toString()))) {
      ++repositoryNumber;
    }
    repositoryFolderPath = jsDevTools.joinPath(repositoryFolderPath, repositoryNumber.toString());
  }
  return repositoryFolderPath;
}

async function logInterestingFiles(files: string[] | undefined, logger: jsDevTools.Logger, fileChange: string): Promise<void> {
  if (files && files.length > 0) {
    await logger.logInfo(`The following files were ${fileChange}:`);
    for (const file of files) {
      await logger.logInfo(`  ${file}`);
    }
  }
}

export class BlobLogger implements jsDevTools.Logger {
  private readonly logs: string[];
  private readonly blob: jsDevTools.BlobStorageBlob;

  constructor(blob: jsDevTools.BlobStorageBlob) {
    this.logs = [];
    this.blob = blob;
  }

  private log(text: string): Promise<void> {
    this.logs.push(text);

    return this.blob.setContentsFromString(`<html><body>${this.logs.join("<br/>")}</body></html>`);
  }

  logInfo(text: string): Promise<void> {
    return this.log(text);
  }

  logError(text: string): Promise<void> {
    return this.log(`ERROR: ${text}`);
  }

  logWarning(text: string): Promise<void> {
    return this.log(`WARNING: ${text}`);
  }

  logSection(text: string): Promise<void> {
    return this.log(`SECTION: ${text}`);
  }

  logVerbose(text: string): Promise<void> {
    return this.log(text);
  }
}

/**
 * The name of the BlobStorage container that will store details about a request that came from a
 * changed pull request.
 */
export const pullRequestsContainerName = "pullrequests";

export const allLogsName = "all.logs.html";

/**
 * The collection of functions that implement the Swagger To SDK service.
 */
export class SwaggerToSDK {
  public readonly workingPrefix: jsDevTools.BlobStoragePrefix;
  public readonly logger: jsDevTools.Logger | undefined;
  public readonly httpClient: jsDevTools.HttpClient;
  public readonly runner: jsDevTools.Runner | undefined;

  constructor(workingPrefix: jsDevTools.BlobStoragePrefix, options?: SwaggerToSDKOptions) {
    options = options || {};
    this.workingPrefix = workingPrefix;
    this.logger = options.logger;
    this.httpClient = options.httpClient || new jsDevTools.NodeHttpClient();
    this.runner = options.runner;
  }

  private getPullRequestPrefix(repository: jsDevTools.GitHubRepository, pullRequestNumber: number): jsDevTools.BlobStoragePrefix {
    return this.workingPrefix
      .getPrefix(jsDevTools.getRepositoryFullName(repository) + "/")
      .getPrefix(pullRequestNumber.toString() + "/");
  }

  private getGenerationInstancePrefix(repository: jsDevTools.GitHubRepository, pullRequestNumber: number, generationInstance: number): jsDevTools.BlobStoragePrefix {
    return this.getPullRequestPrefix(repository, pullRequestNumber)
      .getPrefix(generationInstance.toString() + "/");
  }

  private getAllLogsBlob(generationInstancePrefix: BlobStoragePrefix): jsDevTools.BlobStorageBlob {
    return generationInstancePrefix.getBlob(allLogsName);
  }

  private getRepositoryLogsBlob(generationInstancePrefix: BlobStoragePrefix, repository: GitHubRepository): jsDevTools.BlobStorageBlob {
    return generationInstancePrefix.getBlob(`${getRepositoryFullName(repository).toLowerCase().replace("/", ".")}.logs.html`);
  }

  private async createGenerationInstance(repository: jsDevTools.GitHubRepository, pullRequestNumber: number): Promise<number> {
    // Create the working prefix's container if it doesn't already exist.
    await this.workingPrefix.getContainer().create();

    let generationInstance = 1;
    let generationInstancePrefix: BlobStoragePrefix = this.getGenerationInstancePrefix(repository, pullRequestNumber, generationInstance);
    while (!await this.getAllLogsBlob(generationInstancePrefix).create()) {
      ++generationInstance;
      generationInstancePrefix = this.getGenerationInstancePrefix(repository, pullRequestNumber, generationInstance);
    }

    return generationInstance;
  }

  /**
   * The implementation-independent function that gets called when GitHub invokes a pull request webhook request to our tooling service.
   * @param pullRequestChangeBody The body of the GitHub pull request webhook request.
   */
  public async pullRequestChange(pullRequestChangeBody: jsDevTools.GitHubPullRequestWebhookBody, options?: SwaggerToSDKPullRequestChangeOptions): Promise<void> {
    options = options || {};

    const deleteWorkingFolder: boolean = options.deleteClonedRepositories != undefined ? options.deleteClonedRepositories : true;

    const apiPullRequest: jsDevTools.GitHubPullRequest = pullRequestChangeBody.pull_request;

    const repository: jsDevTools.GitHubRepository = jsDevTools.getGitHubRepository("Azure/azure-rest-api-specs");
    const pullRequestNumber: number = apiPullRequest.number;
    const generationInstance: number = await this.createGenerationInstance(repository, pullRequestNumber);

    const workingFolderPath: string = await getWorkingFolderPath(options.workingFolderPath);
    const generationInstancePrefix: BlobStoragePrefix = this.getGenerationInstancePrefix(repository, pullRequestNumber, generationInstance);
    let logger: jsDevTools.Logger = new BlobLogger(this.getAllLogsBlob(generationInstancePrefix));
    if (this.logger) {
      logger = jsDevTools.getCompositeLogger(logger, this.logger);
    }
    try {
      await logger.logInfo(`Received pull request change webhook request from GitHub for "${apiPullRequest.html_url}".`);

      await logger.logInfo(`Getting diff_url (${apiPullRequest.diff_url}) contents...`);
      const diffUrlResponse: jsDevTools.HttpResponse = await this.httpClient.sendRequest({ method: "GET", url: apiPullRequest.diff_url });
      const statusCodeMessage = `diff_url response status code is ${diffUrlResponse.statusCode}.`;
      if (diffUrlResponse.statusCode !== 200) {
        await logger.logError(statusCodeMessage);
      } else {
        await logger.logInfo(statusCodeMessage);
        if (!diffUrlResponse.body) {
          await logger.logError(`diff_url response body is empty.`);
        } else {
          const diffUrlResponseBodyLines: string[] = diffUrlResponse.body.split(/\r?\n/);
          await logger.logInfo(`diff_url response body contains ${diffUrlResponseBodyLines.length} lines.`);
          const changedFileDiffLinePrefix = "diff --git";
          const diffGitLines: string[] = jsDevTools.where(diffUrlResponseBodyLines, (line: string) => line.startsWith(changedFileDiffLinePrefix));
          await logger.logInfo(`diff_url response body contains ${diffGitLines.length} "${changedFileDiffLinePrefix}" lines.`);
          const changedFileRelativePaths: string[] = jsDevTools.map(diffGitLines, (line: string) => line.match(diffGitLineRegex)![1]);
          await logger.logInfo(`diff_url response body contains ${changedFileRelativePaths.length} changed files:`);
          for (const changedFileRelativePath of changedFileRelativePaths) {
            await logger.logInfo(changedFileRelativePath);
          }
          const specificationChangedFileRelativePaths: string[] = jsDevTools.where(changedFileRelativePaths, (text: string) => text.startsWith("specification/"));
          await logger.logInfo(`diff_url response body contains ${specificationChangedFileRelativePaths.length} changed files in the specification folder:`);
          for (const changedFileRelativePath of specificationChangedFileRelativePaths) {
            await logger.logInfo(changedFileRelativePath);
          }
          const readmeMdRelativeFilePathsToGenerate: string[] = [];
          for (const changedFileRelativePath of specificationChangedFileRelativePaths) {
            let searchString = "/resource-manager/";
            let searchStringIndex: number = changedFileRelativePath.indexOf(searchString);
            if (searchStringIndex === -1) {
              searchString = "/data-plane/";
              searchStringIndex = changedFileRelativePath.indexOf(searchString);
            }

            if (searchStringIndex !== -1) {
              const readmeMdRelativeFilePath = changedFileRelativePath.substr(0, searchStringIndex + searchString.length) + "readme.md";
              if (readmeMdRelativeFilePathsToGenerate.indexOf(readmeMdRelativeFilePath) === -1) {
                readmeMdRelativeFilePathsToGenerate.push(readmeMdRelativeFilePath);
              }
            }
          }
          await logger.logInfo(`Found ${readmeMdRelativeFilePathsToGenerate.length} readme.md files to generate:`);
          for (const readmeMdRelativeFilePathToGenerate of readmeMdRelativeFilePathsToGenerate) {
            await logger.logInfo(readmeMdRelativeFilePathToGenerate);
          }
          for (const readmeMdRelativeFilePathToGenerate of readmeMdRelativeFilePathsToGenerate) {
            await logger.logInfo(`Looking for languages to generate in "${readmeMdRelativeFilePathToGenerate}"...`);
            const mergedReadmeMdFileUrl = `https://raw.githubusercontent.com/azure/azure-rest-api-specs/${apiPullRequest.merge_commit_sha}/${readmeMdRelativeFilePathToGenerate}`;
            await logger.logInfo(`Getting file contents for "${mergedReadmeMdFileUrl}"...`);
            const mergedReadmeMdFileResponse: HttpResponse = await this.httpClient.sendRequest({ method: "GET", url: mergedReadmeMdFileUrl });
            await logger.logInfo(`Merged readme.md response status code is ${mergedReadmeMdFileResponse.statusCode}.`);
            const mergedReadmeMdFileContents: string | undefined = mergedReadmeMdFileResponse.body;
            if (!mergedReadmeMdFileContents) {
              await logger.logError(`Merged readme.md response body is empty.`);
            } else {
              const swaggerToSDKConfiguration: jsDevTools.ReadmeMdSwaggerToSDKConfiguration | undefined = jsDevTools.findSwaggerToSDKConfiguration(mergedReadmeMdFileContents);
              if (!swaggerToSDKConfiguration) {
                await logger.logError(`No SwaggerToSDK configuration YAML block found in the merged readme.md.`);
              } else {
                await logger.logInfo(`Found ${swaggerToSDKConfiguration.repositories.length} requested SDK repositories:`);
                for (const requestedRepository of swaggerToSDKConfiguration.repositories) {
                  await logger.logInfo(requestedRepository.repo);
                }
                for (const requestedRepository of swaggerToSDKConfiguration.repositories) {
                  const repository: GitHubRepository = getGitHubRepository(requestedRepository.repo);
                  if (!repository.organization) {
                    repository.organization = "Azure";
                  }
                  const repoLogger: jsDevTools.Logger = getCompositeLogger(logger, new BlobLogger(this.getRepositoryLogsBlob(generationInstancePrefix, repository)));
                  const fullRepositoryName: string = getRepositoryFullName(repository);
                  const repositoryUrl = `https://github.com/${fullRepositoryName}`;
                  const repositoryExistsResponse: HttpResponse = await this.httpClient.sendRequest({ method: "HEAD", url: repositoryUrl });
                  if (repositoryExistsResponse.statusCode !== 200) {
                    await repoLogger.logError(`Could not find a repository at ${repositoryUrl}.`);
                  } else {
                    const swaggerToSDKConfigFileUrl = `https://raw.githubusercontent.com/${fullRepositoryName}/master/swagger_to_sdk_config.json`;
                    const swaggerToSDKConfigFileResponse: HttpResponse = await this.httpClient.sendRequest({ method: "GET", url: swaggerToSDKConfigFileUrl });
                    if (swaggerToSDKConfigFileResponse.statusCode !== 200) {
                      await repoLogger.logError(`Could not find a swagger_to_sdk_config.json file at ${swaggerToSDKConfigFileUrl}.`);
                    } else {
                      const swaggerToSDKConfigFileContents: string | undefined = swaggerToSDKConfigFileResponse.body;
                      if (!swaggerToSDKConfigFileContents) {
                        await repoLogger.logError(`The swagger_to_sdk_config.json file at ${swaggerToSDKConfigFileUrl} is empty.`);
                      } else {
                        const swaggerToSDKConfig: SwaggerToSDKConfiguration = JSON.parse(swaggerToSDKConfigFileContents);
                        if (!swaggerToSDKConfig.meta) {
                          await repoLogger.logError(`No meta property exists in ${swaggerToSDKConfigFileUrl}.`);
                        } else {
                          const repositoryFolderPath = getRepositoryFolderPath(workingFolderPath, swaggerToSDKConfig);
                          const cloneResult: jsDevTools.RunResult = await jsDevTools.gitClone(repositoryUrl, {
                            runner: this.runner,
                            depth: 1,
                            directory: repositoryFolderPath,
                            quiet: true,
                            log: repoLogger.logInfo,
                            showCommand: true
                          });
                          if (cloneResult.exitCode !== 0) {
                            await repoLogger.logError(`Failed to clone ${repositoryUrl} to ${repositoryFolderPath}:`);
                            if (cloneResult.stderr) {
                              for (const errorMessage of cloneResult.stderr.split(/\r?\n/)) {
                                if (errorMessage) {
                                  await repoLogger.logError(errorMessage);
                                }
                              }
                            }
                          } else {
                            let autorestInstallSource = `autorest`;
                            if (swaggerToSDKConfig.meta.autorest_version) {
                              autorestInstallSource += `@${swaggerToSDKConfig.meta.autorest_version}`;
                            }
                            const installAutorestResult: jsDevTools.RunResult = await npmInstall({
                              runner: this.runner,
                              installSource: autorestInstallSource,
                              executionFolderPath: repositoryFolderPath,
                              showCommand: true,
                              log: repoLogger.logInfo
                            });
                            if (installAutorestResult.exitCode !== 0) {
                              await repoLogger.logError(`Failed to install ${autorestInstallSource}.`);
                            } else {
                              const autorestOptions: jsDevTools.AutoRestOptions = swaggerToSDKConfig.meta.autorest_options || {};

                              for (const autorestOptionName of Object.keys(autorestOptions)) {
                                const autorestOptionValue: jsDevTools.AutoRestOptionValue = autorestOptions[autorestOptionName];
                                if (autorestOptionName.startsWith("sdkrel:") && typeof autorestOptionValue === "string") {
                                  const resolvedAutorestOptionName: string = autorestOptionName.substring("sdkrel:".length);
                                  const resolvedAutorestOptionValue: string = jsDevTools.joinPath(repositoryFolderPath, autorestOptionValue);
                                  delete autorestOptions[autorestOptionName];
                                  autorestOptions[resolvedAutorestOptionName] = resolvedAutorestOptionValue;
                                }
                              }

                              const autorestResult: jsDevTools.RunResult = await jsDevTools.autorest(mergedReadmeMdFileUrl, autorestOptions, {
                                autorestPath: "./node_modules/.bin/autorest",
                                runner: this.runner,
                                executionFolderPath: repositoryFolderPath,
                                showCommand: true,
                                log: repoLogger.logInfo
                              });

                              const nodeModulesFolderPath: string = jsDevTools.joinPath(repositoryFolderPath, "node_modules");
                              if (jsDevTools.folderExistsSync(nodeModulesFolderPath)) {
                                await repoLogger.logInfo(`Deleting folder ${nodeModulesFolderPath}...`);
                                jsDevTools.deleteFolder(nodeModulesFolderPath);
                              }
                              const packageLockJsonFilePath: string = jsDevTools.joinPath(repositoryFolderPath, "package-lock.json");
                              if (jsDevTools.fileExistsSync(packageLockJsonFilePath)) {
                                await repoLogger.logInfo(`Deleting file ${packageLockJsonFilePath}...`);
                                jsDevTools.deleteFile(packageLockJsonFilePath);
                              }
                              const packageJsonFilePath: string = jsDevTools.joinPath(repositoryFolderPath, "package.json");
                              if (jsDevTools.fileExistsSync(packageJsonFilePath)) {
                                await repoLogger.logInfo(`Resetting file ${packageJsonFilePath}...`);
                                gitCheckout("package.json", {
                                  runner: this.runner,
                                  executionFolderPath: repositoryFolderPath,
                                  showCommand: true,
                                  log: repoLogger.logInfo
                                });
                              }

                              if (autorestResult.exitCode !== 0) {
                                await repoLogger.logError(`Failed to run autorest.`);
                              } else {
                                const gitStatusResult: jsDevTools.GitStatusResult = await jsDevTools.gitStatus({
                                  runner: this.runner,
                                  executionFolderPath: repositoryFolderPath,
                                  showCommand: true,
                                  log: repoLogger.logInfo
                                });

                                if (!gitStatusResult.hasUncommittedChanges) {
                                  await repoLogger.logInfo(`No changes were detected after AutoRest ran.`);
                                } else {
                                  await logInterestingFiles(gitStatusResult.untrackedFiles, repoLogger, "added");
                                  await logInterestingFiles(gitStatusResult.notStagedModifiedFiles, repoLogger, "modified");
                                  await logInterestingFiles(gitStatusResult.notStagedDeletedFiles, repoLogger, "deleted");
                                }
                              }
                            }
                          }

                          if (!deleteWorkingFolder) {
                            await repoLogger.logInfo(`Not deleting clone of ${fullRepositoryName} at folder ${repositoryFolderPath}.`);
                          } else {
                            await repoLogger.logInfo(`Deleting clone of ${fullRepositoryName} at folder ${repositoryFolderPath}...`);
                            jsDevTools.deleteFolder(repositoryFolderPath);
                            await repoLogger.logInfo(`Finished deleting clone of ${fullRepositoryName} at folder ${repositoryFolderPath}.`);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } finally {
      if (!deleteWorkingFolder) {
        await logger.logInfo(`Not deleting working folder ${workingFolderPath}.`);
      } else {
        await logger.logInfo(`Deleting working folder ${workingFolderPath}...`);
        jsDevTools.deleteFolder(workingFolderPath);
        await logger.logInfo(`Finished deleting working folder ${workingFolderPath}.`);
      }
    }
  }
}
