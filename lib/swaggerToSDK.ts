import * as jsDevTools from "@ts-common/azure-js-dev-tools";
import { BlobStorageBlob, BlobStoragePrefix, CompressionResult, Compressor, deleteFile, FakeGitHub, getChildFilePaths, getCompositeLogger, getGitHubRepository, getRepositoryFullName, gitCheckout, GitHub, GitHubComment, GitHubRepository, HttpClient, HttpResponse, joinPath, npmInstall, npmPack, run, Runner, RunOptions, RunResult, URLBuilder, GitHubPullRequest } from "@ts-common/azure-js-dev-tools";
import { getLines } from "@ts-common/azure-js-dev-tools/dist/lib/common";
import * as path from "path";

/**
 * Options that can be used within a package command.
 */
export interface PackageCommandOptions extends RunOptions {
  /**
   * The path to the package folder.
   */
  packageFolderPath: string;
  /**
   * The Compressor that can be used to create archives.
   */
  compressor: Compressor;
  /**
   * The Runner that will be used to run external process commands.
   */
  runner: Runner | undefined;
  /**
   * A function that will be used to write logs.
   */
  log: (text: string) => Promise<any> | any;
  /**
   * Whether or not to write the command that will be executed to the console. Defaults to true.
   */
  showCommand: boolean | undefined;
}

/**
 * A configuration for how to interact with repositories in a specific programming language.
 */
export interface LanguageConfiguration {
  /**
   * The name of the programming language.
   */
  name: string;
  /**
   * Aliases that the programming language may also be known by.
   */
  aliases?: string[];
  /**
   * The name of a file that is found at the root of a generated package for this language.
   */
  packageRootFileName?: string;
  /**
   * The commands that should be run to create a package for this language.
   */
  packageCommands?: (((options: PackageCommandOptions) => Promise<any>) | string)[];
  /**
   * The file extension of a package file.
   */
  packageFileExtension?: string;
}

/**
 * A language configuration for JavaScript-based languages.
 */
export const javascript: LanguageConfiguration = {
  name: "JavaScript",
  aliases: ["TypeScript", "TS", "JS", "Node", "Nodejs", "Node.js"],
  packageRootFileName: "package.json",
  packageCommands: [
    options => npmPack({
      ...options,
      executionFolderPath: options.packageFolderPath
    })
  ],
  packageFileExtension: ".tgz"
};

/**
 * A language configuration for Python.
 */
export const python: LanguageConfiguration = {
  name: "Python",
  packageRootFileName: "setup.py"
};

/**
 * A language configuration for C#.
 */
export const csharp: LanguageConfiguration = {
  name: "C#",
  aliases: ["CSharp", "C-Sharp", "CS"]
};

/**
 * A language configuration for Ruby.
 */
export const ruby: LanguageConfiguration = {
  name: "Ruby"
};

/**
 * A language configuration for Go.
 */
export const go: LanguageConfiguration = {
  name: "Go"
};

/**
 * A language configuration for Java.
 */
export const java: LanguageConfiguration = {
  name: "Java",
  packageRootFileName: "pom.xml"
};

/**
 * All of the languages that are supported by SwaggerToSDK.
 */
export function getAllLanguages(): LanguageConfiguration[] {
  return [
    csharp,
    go,
    java,
    javascript,
    python,
    ruby
  ];
}

/**
 * A set of advanced options that can change how SwaggerToSDK interacts with the repository.
 */
export interface AdvancedOptions {
  /**
   * Add more layers of folders to clone the repo, if necessary. Right now, useful for Go only.
   * "sdkrel:" will consider this as the final folder path.
   */
  clone_dir?: string;
  /**
   * An optional list of files/directory to keep when we generate new SDK. This support a
   * Bash-like wildcard syntax (i.e. "my*file.py"). This applies to every Swagger files.
   */
  wrapper_filesOrDirs?: string[];
  /**
   * An optional list of files/directory to delete from the generated SDK. This support a
   * Bash-like wildcard syntax (i.e. "my*file.py") This applies to every Swagger files.
   */
  delete_filesOrDirs?: string[];
  /**
   * If the data to consider generated by Autorest are not directly in the root folder. For
   * instance, if Autorest generates a networkclient folder and you want to consider this folder as
   * the root of data. This parameter is applied before 'delete_filesOrDirs', consider it in your
   * paths. This applies to every Swagger files.
   */
  generated_relative_base_directory?: string;
  /**
   * This is the folder in your SDK repository where you want to put the generated files.
   */
  output_dir?: string;
  /**
   * This is an optional folder where to put metadata about the generation (Autorest version, date
   * of generation, etc.). This can be used by our monitoring system to detect package that needs an
   * update. Be sure this folder is unique in the entire file, to avoid overwritting a file from
   * another project.
   */
  build_dir?: string;
}

/**
 * A set of options for giving specific properties to certain service/resource providers.
 */
export interface Project {
  /**
   * This is an optional parameter which specificy the Autorest MD file path for this project. This
   * is relative to the rest-folder paramter.
   */
  markdown?: string;
  /**
   * An optional dictionary of options you want to pass to Autorest. This will be passed in any
   * call, but can be override by "autorest_options" in each data. Note that you CAN'T override
   * "--output-folder" which is filled contextually. All options prefixed by "sdkrel:" can be a
   * relative path that will be solved against SDK folder before being sent to Autorest.
   */
  autorest_options?: jsDevTools.AutoRestOptions;
  /**
   * An optional list of files/directory to keep when we generate new SDK. This support a
   * Bash-like wildcard syntax (i.e. "my*file.py"). This applies to every Swagger files.
   */
  wrapper_filesOrDirs?: string[];
  /**
   * An optional list of files/directory to delete from the generated SDK. This support a
   * Bash-like wildcard syntax (i.e. "my*file.py") This applies to every Swagger files.
   */
  delete_filesOrDirs?: string[];
  /**
   * If the data to consider generated by Autorest are not directly in the root folder. For
   * instance, if Autorest generates a networkclient folder and you want to consider this folder
   * as the root of data. This parameter is applied before 'delete_filesOrDirs', consider it in
   * your paths. This applies to every Swagger files.
   */
  generated_relative_base_directory?: string;
  /**
   * This is the folder in your SDK repository where you want to put the generated files.
   */
  output_dir?: string;
  /**
   * This is an optional folder where to put metadata about the generation (Autorest version, date
   * of generation, etc.). This can be used by our monitoring system to detect package that needs an
   * update. Be sure this folder is unique in the entire file, to avoid overwritting a file from
   * another project.
   */
  build_dir?: string;
}

/**
 * A configuration that describes how SwaggerToSDK should behave for a specific repository.
 */
export interface SwaggerToSDKConfiguration {
  meta?: {
    /**
     * The version of SwaggerToSDK to use.
     * The version must be 0.2.0.
     */
    version?: string;
    /**
     * List of commands to execute after the generation is done. Will be executed in the order of the
     * list. Current working directory will be the cloned path. See also "envs" node.
     */
    after_scripts?: string[];
    /**
     * The version of autorest to use. Defaults to the latest published version.
     */
    autorest_version?: string;
    /**
     * An optional dictionary of options you want to pass to Autorest. This will be passed in any
     * call, but can be override by "autorest_options" in each data. Note that you CAN'T override
     * "--output-folder" which is filled contextually. All options prefixed by "sdkrel:" can be a
     * relative path that will be solved against SDK folder before being sent to Autorest.
     */
    autorest_options?: jsDevTools.AutoRestOptions;
    /**
     * Environment variables for after_scripts. All options prefixed by "sdkrel:" can be a relative
     * path that will be resolved against SDK folder before being sent to the scripts.
     */
    envs?: jsDevTools.StringMap<string | boolean | number>;
    /**
     * A set of advanced options that can change how SwaggerToSDK interacts with the repository.
     */
    advanced_options?: AdvancedOptions;
    /**
     * An optional list of files/directory to keep when we generate new SDK. This support a
     * Bash-like wildcard syntax (i.e. "my*file.py"). This applies to every Swagger files.
     */
    wrapper_filesOrDirs?: string[];
    /**
     * An optional list of files/directory to delete from the generated SDK. This support a
     * Bash-like wildcard syntax (i.e. "my*file.py") This applies to every Swagger files.
     */
    delete_filesOrDirs?: string[];
    /**
     * If the data to consider generated by Autorest are not directly in the root folder. For
     * instance, if Autorest generates a networkclient folder and you want to consider this folder
     * as the root of data. This parameter is applied before 'delete_filesOrDirs', consider it in
     * your paths. This applies to every Swagger files.
     */
    generated_relative_base_directory?: string;
    /**
     * A file that marks the root of a package. In Node.js this is package.json. In Python it's
     * setup.py.
     */
    package_root_file?: string;
  };
  /**
   * It's a dict where keys are a project id. The project id has no constraint, but it's recommended
   * to use namespace style, like "datalake.store.account" to provide the best flexibility for the
   * --project parameter.
   */
  projects?: jsDevTools.StringMap<Project>;
}

/**
 * The regular expression used to get a relative file path from a pull request diff_url contents
 * line.
 */
const diffGitLineRegex: RegExp = /diff --git a\/(.*) b\/.*/;

/**
 * Create a temporary folder in the provided rooted folder path. The created temporary folder's path
 * will be returned.
 * @param baseFolderPath The rooted path to the folder to create a temporary folder in.
 */
export async function createTempFolder(baseFolderPath: string): Promise<string> {
  let count = 1;
  let workingFolderPath: string = jsDevTools.joinPath(baseFolderPath, count.toString());
  while (!await jsDevTools.createFolder(workingFolderPath)) {
    ++count;
    workingFolderPath = jsDevTools.joinPath(baseFolderPath, count.toString());
  }
  return workingFolderPath;
}

/**
 * Create a temporary working folder in the provided base working folder path. If a temporary folder
 * cannot be created in the provided base working folder path, then this function will attempt to
 * create a temporary working folder in the current working directory.
 * @param baseWorkingFolderPath The ideal folder that working folders will be created in.
 */
export async function getWorkingFolderPath(baseWorkingFolderPath: string | undefined): Promise<string> {
  const customBaseWorkingFolderPath: boolean = !!baseWorkingFolderPath;
  if (!baseWorkingFolderPath) {
    baseWorkingFolderPath = process.cwd();
  } else if (!jsDevTools.isRooted(baseWorkingFolderPath)) {
    baseWorkingFolderPath = jsDevTools.joinPath(process.cwd(), baseWorkingFolderPath);
  }

  let workingFolderPath: string;
  try {
    workingFolderPath = await createTempFolder(baseWorkingFolderPath);
  } catch (error) {
    if (!customBaseWorkingFolderPath) {
      throw error;
    } else {
      // Error when trying to create the working folder path. Fall back to creating a temporary
      // folder in the current working directory.
      workingFolderPath = await createTempFolder(process.cwd());
    }
  }

  return workingFolderPath;
}

/**
 * Get the path that the repository should be cloned to.
 * @param generationInstanceFolderPath The path to the current generation instance's working folder.
 * @param swaggerToSDKConfig The SwaggerToSDK configuration from the repository.
 * @param repositoryNumber The repository's number in the ordered of repositories in the
 * generation's readme.md file.
 */
export function getRepositoryFolderPath(generationInstanceFolderPath: string, swaggerToSDKConfig: SwaggerToSDKConfiguration, repositoryNumber: number): string {
  let repositoryFolderPath = `${generationInstanceFolderPath}`;
  if (swaggerToSDKConfig.meta &&
    swaggerToSDKConfig.meta.advanced_options &&
    swaggerToSDKConfig.meta.advanced_options.clone_dir) {
    repositoryFolderPath = jsDevTools.joinPath(repositoryFolderPath, swaggerToSDKConfig.meta.advanced_options.clone_dir);
  } else {
    repositoryFolderPath = jsDevTools.joinPath(repositoryFolderPath, repositoryNumber.toString());
  }
  return repositoryFolderPath;
}

/**
 * Get the name of the file where the repository's contents will be compressed to.
 * @param repository The repository that will be compressed.
 * @param extension The file extension to add to the compressed repository file name.
 */
export function getCompressedRepositoryFileName(repository: string | GitHubRepository, extension: string): string {
  if (!extension.startsWith(".")) {
    extension = `.${extension}`;
  }
  return `${getRepositoryFullName(repository).toLowerCase().replace("/", ".")}${extension}`;
}

/**
 * Get the prefix that all blobs related to the pull request will be put in.
 * @param workingPrefix The prefix that this service operates under.
 * @param repository The repository that the pull request exists in.
 * @param pullRequestNumber The pull request number.
 */
export function getPullRequestPrefix(workingPrefix: BlobStoragePrefix, repository: string | jsDevTools.GitHubRepository, pullRequestNumber: number): jsDevTools.BlobStoragePrefix {
  return workingPrefix
    .getPrefix(jsDevTools.getRepositoryFullName(repository) + "/")
    .getPrefix(pullRequestNumber.toString() + "/");
}

/**
 * Get the prefix that all blobs related to this generation instance will be put in.
 * @param pullRequestPrefix The prefix that the pull request operates under.
 * @param generationInstance The number of generations that have occurred for the pull request.
 */
export function getGenerationInstancePrefix(pullRequestPrefix: BlobStoragePrefix, generationInstance: number): jsDevTools.BlobStoragePrefix {
  return pullRequestPrefix.getPrefix(generationInstance.toString() + "/");
}

/**
 * Claim a generation instance for the provided pull request by creating the logs blob.
 * @param pullRequestPrefix The prefix of the pull request that this generation instance belongs to.
 */
export async function createGenerationInstance(pullRequestPrefix: BlobStoragePrefix): Promise<number> {
  // Create the pull request prefix's container if it doesn't already exist.
  await pullRequestPrefix.getContainer().create({
    accessPolicy: "blob"
  });

  let generationInstance = 1;
  let generationInstancePrefix: BlobStoragePrefix = getGenerationInstancePrefix(pullRequestPrefix, generationInstance);
  while (!await getLogsBlob(generationInstancePrefix).create()) {
    ++generationInstance;
    generationInstancePrefix = getGenerationInstancePrefix(pullRequestPrefix, generationInstance);
  }

  return generationInstance;
}

/**
 * Log each of the provided files with a header explaining how they were changed.
 * @param changedFiles The files that were changed.
 * @param logger The logger to use.
 * @param changeType The type of change that occurred.
 */
export async function logChangedFiles(changedFiles: string[] | undefined, logger: jsDevTools.Logger, changeType: string): Promise<void> {
  if (changedFiles && changedFiles.length > 0) {
    await logger.logInfo(`The following files were ${changeType}:`);
    for (const file of changedFiles) {
      await logger.logInfo(`  ${file}`);
    }
  }
}

export function getBlobLogger(blob: jsDevTools.BlobStorageBlob): jsDevTools.Logger {
  const logs: string[] = [];
  function log(text: string): Promise<void> {
    logs.push(text);
    return blob.setContentsFromString(logs.join("\n"), {
      contentType: "text/plain"
    });
  }
  return {
    logInfo: log,
    logError: log,
    logWarning: log,
    logSection: log,
    logVerbose: log,
  };
}

/**
 * Get the languages that are supported by this instance of SwaggerToSDK.
 * @param languages The languages that are supported by this instance of SwaggerToSDK.
 */
export function getSupportedLanguages(languages: undefined | LanguageConfiguration[] | ((defaultLanguages: LanguageConfiguration[]) => void | LanguageConfiguration[])): LanguageConfiguration[] {
  let result: LanguageConfiguration[];
  if (Array.isArray(languages)) {
    result = languages;
  } else {
    result = getAllLanguages();
    if (languages) {
      const functionResult: void | LanguageConfiguration[] = languages(result);
      if (functionResult) {
        result = functionResult;
      }
    }
  }
  return result;
}

/**
 * Get the registered LanguageConfiguration for the provided GitHub repository.
 * @param repository The repository to get a LanguageConfiguration for.
 * @param supportedLanguages The languages that this operation supports.
 */
export function getLanguageForRepository(repository: string | GitHubRepository, supportedLanguages: LanguageConfiguration[]): LanguageConfiguration | undefined {
  const lowerCasedRepositoryFullName: string = jsDevTools.getRepositoryFullName(repository).toLowerCase();
  return jsDevTools.first(supportedLanguages, (language: LanguageConfiguration) => {
    let matches: boolean = (lowerCasedRepositoryFullName.indexOf(language.name.toLowerCase()) !== -1);
    if (!matches && language.aliases) {
      for (const alias of language.aliases) {
        matches = lowerCasedRepositoryFullName.indexOf(alias.toLowerCase()) !== -1;
        if (matches) {
          break;
        }
      }
    }
    return matches;
  });
}

export function getGitHub(github: GitHub | undefined): GitHub {
  return github || new FakeGitHub();
}

export function getCompressorCreator(compressorCreator: (() => Compressor) | undefined): () => Compressor {
  return compressorCreator || (() => new jsDevTools.ArchiverCompressor());
}

export function getHttpClient(httpClient: HttpClient | undefined): HttpClient {
  return httpClient || new jsDevTools.NodeHttpClient();
}

export function getGenerationBlob(generationInstancePrefix: BlobStoragePrefix): BlobStorageBlob {
  return generationInstancePrefix.getBlob("generation.json");
}

export function getLogsBlob(prefix: BlobStoragePrefix): BlobStorageBlob {
  return prefix.getBlob("logs.txt");
}

const pullRequestUrlRepositoryNameRegex: RegExp = /https:\/\/api\.github\.com\/repos\/(.*)\/pulls\/.*/;
/**
 * Get the GitHub repository from the provided pull request URL.
 * @param pullRequestUrl The URL to get the GitHub repository from.
 */
export function getPullRequestRepository(pullRequestUrl: string): GitHubRepository | undefined {
  let result: GitHubRepository | undefined;
  const match: RegExpMatchArray | null = pullRequestUrl.match(pullRequestUrlRepositoryNameRegex);
  if (match) {
    result = getGitHubRepository(match[1]);
  }
  return result;
}

export interface CreateGenerationOptions {
  /**
   * The logger object that SwaggerToSDK will use. Defaults to InMemoryLogger.
   */
  logger?: jsDevTools.Logger;
  /**
   * The GitHub object that SwaggerToSDK will use to create and update comments and to create pull
   * requests.
   */
  github?: GitHub;
  /**
   * The languages that have are supported by this generation.
   */
  supportedLanguages?: LanguageConfiguration[] | ((defaultLanguages: LanguageConfiguration[]) => LanguageConfiguration[]);
  /**
   * A factory function that will be used to create a Compressor used to compress folders for
   * uploading.
   */
  compressorCreator?: () => jsDevTools.Compressor;
  /**
   * The runner object that will be used to execute external-process commands.
   */
  runner?: jsDevTools.Runner;
  /**
   * The client that will be used to send HTTP requests.
   */
  httpClient?: jsDevTools.HttpClient;
  /**
   * The folder where SwaggerToSDK can create folders and clone repositories to. If this isn't
   * defined, then the current working directory will be used.
   */
  workingFolderPath?: string;
  /**
   * Whether or not to delete the locally cloned repositories used for generation. Defaults to true.
   */
  deleteClonedRepositories?: boolean;
  /**
   * Whether or not to compress and upload the cloned repositories after AutoRest has been run.
   * Defaults to false.
   */
  uploadClonedRepositories?: boolean;
  /**
   * The pull request that this Generation is targeting.
   */
  pullRequest?: GitHubPullRequest;
}

export async function createGeneration(workingPrefix: BlobStoragePrefix, options: CreateGenerationOptions | undefined): Promise<Generation> {
  options = options || {};

  const generation: Generation = {
    compressorCreator: getCompressorCreator(options.compressorCreator),
    supportedLanguages: getSupportedLanguages(options.supportedLanguages),
    github: getGitHub(options.github),
    runner: options.runner,
    httpClient: getHttpClient(options.httpClient),
    workingFolderPath: await getWorkingFolderPath(options.workingFolderPath),
    deleteClonedRepositories: options.deleteClonedRepositories == undefined ? true : options.deleteClonedRepositories,
    uploadClonedRepositories: options.uploadClonedRepositories == undefined ? false : options.uploadClonedRepositories,
    workingPrefix,
  };

  const pullRequest: GitHubPullRequest | undefined = options.pullRequest;
  if (pullRequest) {
    generation.data = {
      pullRequest: {
        repository: getPullRequestRepository(pullRequest.url)!,
        number: pullRequest.number,
        htmlUrl: pullRequest.html_url,
        diffUrl: pullRequest.diff_url,
        mergeCommit: pullRequest.merge_commit_sha!,
      },
      repositories: {}
    };
  }

  return generation;
}

export interface Generation {
  /**
   * A factory function that will be used to create a Compressor used to compress folders for
   * uploading.
   */
  compressorCreator: () => Compressor;
  /**
   * The languages that have are supported by this generation.
   */
  supportedLanguages: LanguageConfiguration[];
  /**
   * The GitHub object that SwaggerToSDK will use to create and update comments and to create pull
   * requests.
   */
  github: GitHub;
  /**
   * The runner object that will be used to execute external-process commands.
   */
  runner?: Runner;
  /**
   * The client that will be used to send HTTP requests.
   */
  httpClient: jsDevTools.HttpClient;
  /**
   * The folder where SwaggerToSDK can create folders and clone repositories to. If this isn't
   * defined, then the current working directory will be used.
   */
  workingFolderPath: string;
  /**
   * Whether or not to delete the locally cloned repositories used for generation. Defaults to true.
   */
  deleteClonedRepositories: boolean;
  /**
   * Whether or not to compress and upload the cloned repositories after AutoRest has been run.
   * Defaults to false.
   */
  uploadClonedRepositories: boolean;
  /**
   * The prefix that all blobs created by this service will go under.
   */
  workingPrefix: BlobStoragePrefix;
  /**
   * The prefix that all blobs related to a specific pull request will go under.
   */
  pullRequestPrefix?: BlobStoragePrefix;
  /**
   * The serializable data associated with this generation.
   */
  data?: GenerationData;
}

export interface GenerationData {
  pullRequest: GenerationDataPullRequest;
  commentId?: number;
  logsBlobUrl?: string;
  repositories: jsDevTools.StringMap<GenerationRepository>;
}

export interface GenerationDataPullRequest {
  repository: GitHubRepository;
  number: number;
  htmlUrl: string;
  diffUrl: string;
  mergeCommit: string;
}

export const generationStatus = {
  pending: `Pending`,
  inProgress: `In-Progress`,
  failed: `Failed`,
  succeeded: `Succeeded`
};

export interface GenerationRepository {
  fullName: string;
  status: keyof typeof generationStatus;
  logsBlobUrl?: string;
  pullRequestUrl?: string;
  packages?: GenerationRepositoryPackage[];
}

export interface GenerationRepositoryPackage {
  name: string;
  status: keyof typeof generationStatus;
  logsBlobUrl?: string;
  packageBlobUrl?: string;
}

/**
 * The implementation-independent function that gets called when GitHub invokes a pull request webhook request to our tooling service.
 * @param pullRequestChangeBody The body of the GitHub pull request webhook request.
 */
export async function pullRequestChange(pullRequestChangeBody: jsDevTools.GitHubPullRequestWebhookBody, workingPrefix: BlobStoragePrefix, options?: CreateGenerationOptions): Promise<void> {
  options = options || {};

  const generation: Generation = await createGeneration(workingPrefix, {
    ...options,
    pullRequest: pullRequestChangeBody.pull_request,
  });

  const pullRequestPrefix: BlobStoragePrefix = getPullRequestPrefix(generation.workingPrefix, generation.data!.pullRequest.repository, generation.data!.pullRequest.number);
  const generationInstance: number = await createGenerationInstance(pullRequestPrefix);

  const generationInstancePrefix: BlobStoragePrefix = getGenerationInstancePrefix(pullRequestPrefix, generationInstance);
  const generationInstanceLogsBlob: jsDevTools.BlobStorageBlob = getLogsBlob(generationInstancePrefix);
  let logger: jsDevTools.Logger = getBlobLogger(generationInstanceLogsBlob);
  if (options.logger) {
    logger = jsDevTools.getCompositeLogger(logger, options.logger);
  }

  try {
    await logger.logSection(`Received pull request change webhook request from GitHub for "${generation.data!.pullRequest.htmlUrl}".`);

    const generationBlob: BlobStorageBlob = getGenerationBlob(generationInstancePrefix);
    const previousGenerationBlob: BlobStorageBlob = getGenerationBlob(getGenerationInstancePrefix(pullRequestPrefix, generationInstance - 1));
    const nextGenerationBlob: BlobStorageBlob = getGenerationBlob(getGenerationInstancePrefix(pullRequestPrefix, generationInstance + 1));

    await logger.logSection(`Getting generation state from ${URLBuilder.parse(previousGenerationBlob.getURL()).setQuery(undefined).toString()}...`);

    const generationHtmlBlob: BlobStorageBlob = generationInstancePrefix.getBlob("generation.html");

    async function postGenerationStateToBlobs(generation: GenerationData, generationHTML: string): Promise<any> {
      return Promise.all([
        writeGenerationDataToBlob(generationBlob, generation),
        generationHtmlBlob.setContentsFromString(generationHTML, { contentType: "text/html" })
      ]);
    }

    const generationData: GenerationData = await previousGenerationBlob.getContentsAsString()
      .then(async (previousGenerationBlobContent: string | undefined) => {
        let previousGenerationCommentIdPromise: Promise<number | undefined>;
        if (previousGenerationBlobContent) {
          try {
            const previousGeneration: GenerationData = JSON.parse(previousGenerationBlobContent);
            previousGenerationCommentIdPromise = Promise.resolve(previousGeneration.commentId);
          } catch (error) {
            const errorMessage = `Failed to parse generation blob content: ${JSON.stringify(error)}`;
            await logger.logError(errorMessage);
            previousGenerationCommentIdPromise = Promise.reject(error);
          }
        } else {
          const errorMessage = "Generation blob didn't have any content.";
          await logger.logError(errorMessage);
          previousGenerationCommentIdPromise = Promise.reject(new Error(errorMessage));
        }
        return previousGenerationCommentIdPromise;
      })
      .catch(async () => {
        const newCommentText: string = getGenerationDataHTML();
        const newComment: GitHubComment = await generation.github.createPullRequestComment(generation.data!.pullRequest.repository, generation.data!.pullRequest.number, newCommentText);
        return newComment.id;
      })
      .then(async (commentId: number | undefined) => {
        if (commentId == undefined) {
          const newCommentText: string = getGenerationDataHTML();
          const newComment: GitHubComment = await generation.github.createPullRequestComment(generation.data!.pullRequest.repository, generation.data!.pullRequest.number, newCommentText);
          commentId = newComment.id;
        }
        return commentId;
      })
      .then(async (commentId: number) => {
        const newGeneration: GenerationData = {
          pullRequest: {
            repository: generation.data!.pullRequest.repository,
            number: generation.data!.pullRequest.number,
            htmlUrl: generation.data!.pullRequest.htmlUrl,
            diffUrl: generation.data!.pullRequest.diffUrl,
            mergeCommit: generation.data!.pullRequest.mergeCommit,
          },
          commentId,
          logsBlobUrl: URLBuilder.parse(generationInstanceLogsBlob.getURL()).setQuery(undefined).toString(),
          repositories: {}
        };
        await postGenerationStateToBlobs(newGeneration, getGenerationDataHTML(newGeneration));
        return newGeneration;
      });

      generation.data!.commentId = generationData.commentId;

    async function postGenerationState(generation: Generation): Promise<any> {
      const resultPromises: Promise<any>[] = [];
      const generationData: GenerationData | undefined = generation.data;
      if (generationData) {
        const generationHTML: string = getGenerationDataHTML(generation.data);

        resultPromises.push(postGenerationStateToBlobs(generationData, generationHTML));

        if (await nextGenerationBlob.exists()) {
          resultPromises.push(generation.github.updatePullRequestComment(generation.data!.pullRequest.repository, generation.data!.pullRequest.number, generationData.commentId!, generationHTML));
        }
      }
      return Promise.all(resultPromises);
    }

    await logger.logSection(`Getting diff_url (${generation.data!.pullRequest.diffUrl}) contents...`);
    const diffUrlResponse: jsDevTools.HttpResponse = await generation.httpClient.sendRequest({ method: "GET", url: generation.data!.pullRequest.diffUrl });
    const statusCodeMessage = `diff_url response status code is ${diffUrlResponse.statusCode}.`;
    if (diffUrlResponse.statusCode !== 200) {
      await logger.logError(statusCodeMessage);
    } else {
      await logger.logInfo(statusCodeMessage);
      if (!diffUrlResponse.body) {
        await logger.logError(`diff_url response body is empty.`);
      } else {
        const diffUrlResponseBodyLines: string[] = diffUrlResponse.body.split(/\r?\n/);
        await logger.logInfo(`diff_url response body contains ${diffUrlResponseBodyLines.length} lines.`);
        const changedFileDiffLinePrefix = "diff --git";
        const diffGitLines: string[] = jsDevTools.where(diffUrlResponseBodyLines, (line: string) => line.startsWith(changedFileDiffLinePrefix));
        await logger.logInfo(`diff_url response body contains ${diffGitLines.length} "${changedFileDiffLinePrefix}" lines.`);
        const changedFileRelativePaths: string[] = jsDevTools.map(diffGitLines, (line: string) => line.match(diffGitLineRegex)![1]);
        await logger.logInfo(`diff_url response body contains ${changedFileRelativePaths.length} changed files:`);
        for (const changedFileRelativePath of changedFileRelativePaths) {
          await logger.logInfo(changedFileRelativePath);
        }
        const specificationChangedFileRelativePaths: string[] = jsDevTools.where(changedFileRelativePaths, (text: string) => text.startsWith("specification/"));
        await logger.logInfo(`diff_url response body contains ${specificationChangedFileRelativePaths.length} changed files in the specification folder:`);
        for (const changedFileRelativePath of specificationChangedFileRelativePaths) {
          await logger.logInfo(changedFileRelativePath);
        }
        const readmeMdRelativeFilePathsToGenerate: string[] = [];
        for (const changedFileRelativePath of specificationChangedFileRelativePaths) {
          let searchString = "/resource-manager/";
          let searchStringIndex: number = changedFileRelativePath.indexOf(searchString);
          if (searchStringIndex === -1) {
            searchString = "/data-plane/";
            searchStringIndex = changedFileRelativePath.indexOf(searchString);
          }

          if (searchStringIndex !== -1) {
            const readmeMdRelativeFilePath = changedFileRelativePath.substr(0, searchStringIndex + searchString.length) + "readme.md";
            if (readmeMdRelativeFilePathsToGenerate.indexOf(readmeMdRelativeFilePath) === -1) {
              readmeMdRelativeFilePathsToGenerate.push(readmeMdRelativeFilePath);
            }
          }
        }
        await logger.logInfo(`Found ${readmeMdRelativeFilePathsToGenerate.length} readme.md files to generate:`);
        for (const readmeMdRelativeFilePathToGenerate of readmeMdRelativeFilePathsToGenerate) {
          await logger.logInfo(readmeMdRelativeFilePathToGenerate);
        }
        for (const readmeMdRelativeFilePathToGenerate of readmeMdRelativeFilePathsToGenerate) {
          await logger.logSection(`Looking for languages to generate in "${readmeMdRelativeFilePathToGenerate}"...`);
          const mergedReadmeMdFileUrl = `https://raw.githubusercontent.com/azure/azure-rest-api-specs/${generation.data!.pullRequest.mergeCommit}/${readmeMdRelativeFilePathToGenerate}`;
          await logger.logSection(`Getting file contents for "${mergedReadmeMdFileUrl}"...`);
          const mergedReadmeMdFileResponse: HttpResponse = await generation.httpClient.sendRequest({ method: "GET", url: mergedReadmeMdFileUrl });
          await logger.logInfo(`Merged readme.md response status code is ${mergedReadmeMdFileResponse.statusCode}.`);
          const mergedReadmeMdFileContents: string | undefined = mergedReadmeMdFileResponse.body;
          if (!mergedReadmeMdFileContents) {
            await logger.logError(`Merged readme.md response body is empty.`);
          } else {
            const swaggerToSDKConfiguration: jsDevTools.ReadmeMdSwaggerToSDKConfiguration | undefined = jsDevTools.findSwaggerToSDKConfiguration(mergedReadmeMdFileContents);
            if (!swaggerToSDKConfiguration) {
              await logger.logError(`No SwaggerToSDK configuration YAML block found in the merged readme.md.`);
            } else {
              await logger.logInfo(`Found ${swaggerToSDKConfiguration.repositories.length} requested SDK repositories:`);
              for (const requestedRepository of swaggerToSDKConfiguration.repositories) {
                const repository: GitHubRepository = getGitHubRepository(requestedRepository.repo);
                if (!repository.organization) {
                  repository.organization = "Azure";
                }
                requestedRepository.repo = getRepositoryFullName(repository);
                await logger.logInfo(requestedRepository.repo);
                generationData.repositories[requestedRepository.repo] = {
                  fullName: requestedRepository.repo,
                  status: "pending"
                };
              }

              await postGenerationState(generation);

              let repositoryIndex = 0;
              for (const requestedRepository of swaggerToSDKConfiguration.repositories) {
                const repositoryNumber: number = ++repositoryIndex;
                const repository: GitHubRepository = getGitHubRepository(requestedRepository.repo);
                const fullRepositoryName: string = getRepositoryFullName(repository);
                const repositoryPrefix: jsDevTools.BlobStoragePrefix = generationInstancePrefix.getPrefix(`${fullRepositoryName}/`);
                const repoLoggerBlob: jsDevTools.BlobStorageBlob = getLogsBlob(repositoryPrefix);
                const repoLogger: jsDevTools.Logger = getCompositeLogger(logger, getBlobLogger(repoLoggerBlob));
                const repositoryUrl = `https://github.com/${fullRepositoryName}`;
                await repoLogger.logSection(`Checking if ${repositoryUrl} exists...`);

                const generationRepository: GenerationRepository = generationData.repositories[fullRepositoryName];
                generationRepository.status = "inProgress";
                generationRepository.logsBlobUrl = URLBuilder.parse(repoLoggerBlob.getURL()).setQuery(undefined).toString();
                await postGenerationState(generation);

                function repoError(errorMessage: string): Promise<any> {
                  generationRepository.status = "failed";
                  return Promise.all([
                    repoLogger.logError(errorMessage),
                    postGenerationState(generation)
                  ]);
                }

                const repositoryExistsResponse: HttpResponse = await generation.httpClient.sendRequest({ method: "HEAD", url: repositoryUrl });
                if (repositoryExistsResponse.statusCode !== 200) {
                  await repoError(`Could not find a repository at ${repositoryUrl}.`);
                } else {
                  const swaggerToSDKConfigFileUrl = `https://raw.githubusercontent.com/${fullRepositoryName}/master/swagger_to_sdk_config.json`;
                  const swaggerToSDKConfigFileResponse: HttpResponse = await generation.httpClient.sendRequest({ method: "GET", url: swaggerToSDKConfigFileUrl });
                  if (swaggerToSDKConfigFileResponse.statusCode !== 200) {
                    await repoError(`Could not find a swagger_to_sdk_config.json file at ${swaggerToSDKConfigFileUrl}.`);
                  } else {
                    const swaggerToSDKConfigFileContents: string | undefined = swaggerToSDKConfigFileResponse.body;
                    if (!swaggerToSDKConfigFileContents) {
                      await repoError(`The swagger_to_sdk_config.json file at ${swaggerToSDKConfigFileUrl} is empty.`);
                    } else {
                      const swaggerToSDKConfig: SwaggerToSDKConfiguration = JSON.parse(swaggerToSDKConfigFileContents);
                      if (!swaggerToSDKConfig.meta) {
                        await repoError(`No meta property exists in ${swaggerToSDKConfigFileUrl}.`);
                      } else {
                        const repositoryFolderPath = getRepositoryFolderPath(generation.workingFolderPath, swaggerToSDKConfig, repositoryNumber);
                        const cloneResult: jsDevTools.RunResult = await jsDevTools.gitClone(repositoryUrl, {
                          runner: generation.runner,
                          depth: 1,
                          directory: repositoryFolderPath,
                          quiet: true,
                          log: repoLogger.logInfo,
                          showCommand: true
                        });
                        if (cloneResult.exitCode !== 0) {
                          await repoError(`Failed to clone ${repositoryUrl} to ${repositoryFolderPath}:`);
                          if (cloneResult.stdout) {
                            for (const message of getLines(cloneResult.stdout)) {
                              if (message) {
                                await repoError(message);
                              }
                            }
                          }
                          if (cloneResult.stderr) {
                            for (const errorMessage of getLines(cloneResult.stderr)) {
                              if (errorMessage) {
                                await repoError(errorMessage);
                              }
                            }
                          }
                          if (cloneResult.error) {
                            await repoError(JSON.stringify(cloneResult.error));
                          }
                        } else {
                          let autorestInstallSource = `autorest`;
                          if (swaggerToSDKConfig.meta.autorest_version) {
                            autorestInstallSource += `@${swaggerToSDKConfig.meta.autorest_version}`;
                          }
                          const installAutorestResult: jsDevTools.RunResult = await npmInstall({
                            runner: generation.runner,
                            installSource: autorestInstallSource,
                            executionFolderPath: repositoryFolderPath,
                            showCommand: true,
                            log: repoLogger.logInfo
                          });
                          if (installAutorestResult.exitCode !== 0) {
                            await repoError(`Failed to install ${autorestInstallSource}.`);
                          } else {
                            const autorestOptions: jsDevTools.AutoRestOptions = swaggerToSDKConfig.meta.autorest_options || {};

                            for (const autorestOptionName of Object.keys(autorestOptions)) {
                              const autorestOptionValue: jsDevTools.AutoRestOptionValue = autorestOptions[autorestOptionName];
                              if (autorestOptionName.startsWith("sdkrel:") && typeof autorestOptionValue === "string") {
                                const resolvedAutorestOptionName: string = autorestOptionName.substring("sdkrel:".length);
                                const resolvedAutorestOptionValue: string = jsDevTools.joinPath(repositoryFolderPath, autorestOptionValue);
                                delete autorestOptions[autorestOptionName];
                                autorestOptions[resolvedAutorestOptionName] = resolvedAutorestOptionValue;
                              }
                            }

                            const autorestResult: jsDevTools.RunResult = await jsDevTools.autorest(mergedReadmeMdFileUrl, autorestOptions, {
                              autorestPath: "./node_modules/.bin/autorest",
                              runner: generation.runner,
                              executionFolderPath: repositoryFolderPath,
                              showCommand: true,
                              log: repoLogger.logInfo
                            });

                            const nodeModulesFolderPath: string = jsDevTools.joinPath(repositoryFolderPath, "node_modules");
                            if (jsDevTools.folderExistsSync(nodeModulesFolderPath)) {
                              await repoLogger.logSection(`Deleting folder ${nodeModulesFolderPath}...`);
                              jsDevTools.deleteFolder(nodeModulesFolderPath);
                            }
                            const packageLockJsonFilePath: string = jsDevTools.joinPath(repositoryFolderPath, "package-lock.json");
                            if (jsDevTools.fileExistsSync(packageLockJsonFilePath)) {
                              await repoLogger.logSection(`Deleting file ${packageLockJsonFilePath}...`);
                              jsDevTools.deleteFile(packageLockJsonFilePath);
                            }
                            const packageJsonFilePath: string = jsDevTools.joinPath(repositoryFolderPath, "package.json");
                            if (jsDevTools.fileExistsSync(packageJsonFilePath)) {
                              await repoLogger.logSection(`Resetting file ${packageJsonFilePath}...`);
                              await gitCheckout("package.json", {
                                runner: generation.runner,
                                executionFolderPath: repositoryFolderPath,
                                showCommand: true,
                                log: repoLogger.logInfo
                              });
                            }

                            if (autorestResult.exitCode !== 0) {
                              await repoError(`Failed to run autorest.`);
                            } else {
                              const gitStatusResult: jsDevTools.GitStatusResult = await jsDevTools.gitStatus({
                                runner: generation.runner,
                                executionFolderPath: repositoryFolderPath,
                                showCommand: true,
                                log: repoLogger.logInfo
                              });

                              if (!gitStatusResult.hasUncommittedChanges) {
                                await repoLogger.logInfo(`No changes were detected after AutoRest ran.`);
                              } else {
                                await logChangedFiles(gitStatusResult.untrackedFiles, repoLogger, "added");
                                await logChangedFiles(gitStatusResult.notStagedModifiedFiles, repoLogger, "modified");
                                await logChangedFiles(gitStatusResult.notStagedDeletedFiles, repoLogger, "deleted");
                              }

                              if (options.uploadClonedRepositories) {
                                const compressedRepositoryFileName: string = getCompressedRepositoryFileName(repository, ".zip");
                                const compressedRepositoryFilePath: string = jsDevTools.joinPath(generation.workingFolderPath, compressedRepositoryFileName);
                                await repoLogger.logSection(`Compressing ${repositoryFolderPath} to ${compressedRepositoryFilePath}...`);
                                const compressor: jsDevTools.Compressor = generation.compressorCreator();
                                const repoFolderCompressionResult: CompressionResult = await compressor.zip(repositoryFolderPath, compressedRepositoryFilePath);
                                if (repoFolderCompressionResult.warnings && repoFolderCompressionResult.warnings.length > 0) {
                                  for (const warning of repoFolderCompressionResult.warnings) {
                                    await repoLogger.logWarning(JSON.stringify(warning));
                                  }
                                }
                                if (repoFolderCompressionResult.errors && repoFolderCompressionResult.errors.length > 0) {
                                  for (const error of repoFolderCompressionResult.errors) {
                                    await repoError(JSON.stringify(error));
                                  }
                                }

                                const repositoryZipBlob: jsDevTools.BlobStorageBlob = repositoryPrefix.getBlob(compressedRepositoryFileName);
                                const repositoryZipBlobURLBuilder: URLBuilder = URLBuilder.parse(repositoryZipBlob.getURL());
                                // Get rid of the SAS in the URL.
                                repositoryZipBlobURLBuilder.setQuery(undefined);
                                repoLogger.logSection(`Uploading compressed repository to ${repositoryZipBlobURLBuilder.toString()}...`);
                                try {
                                  await repositoryZipBlob.setContentsFromFile(compressedRepositoryFilePath);
                                  repoLogger.logInfo(`  Done uploading compressed repository to ${repositoryZipBlobURLBuilder.toString()}...`);
                                } finally {
                                  deleteFile(compressedRepositoryFilePath);
                                }
                              }

                              const repositoryLanguage: LanguageConfiguration | undefined = getLanguageForRepository(repository, generation.supportedLanguages);
                              if (!repositoryLanguage) {
                                const languageNames: string[] = jsDevTools.map(generation.supportedLanguages, language => language.name);
                                await repoError(`No programming language registered ${JSON.stringify(languageNames)} that matches the repository ${fullRepositoryName}.`);
                              } else {
                                await repoLogger.logInfo(`Repository ${fullRepositoryName} matches programming language ${repositoryLanguage.name}.`);
                                if (!repositoryLanguage.packageRootFileName) {
                                  await repoLogger.logInfo(`No packageRootFileName property has been specified in the language configuration for ${repositoryLanguage.name}.`);
                                } else {
                                  const changedPackageFolders: string[] = [];
                                  for (const modifiedFile of gitStatusResult.modifiedFiles) {
                                    const packageRootFilePath: string | undefined = jsDevTools.findFileInPathSync(repositoryLanguage.packageRootFileName, modifiedFile);
                                    if (!packageRootFilePath) {
                                      await repoLogger.logWarning(`No package root file found for modified file ${modifiedFile}.`);
                                    } else {
                                      await repoLogger.logVerbose(`Found package root file ${packageRootFilePath} for modified file ${modifiedFile}.`);
                                      const packageFolderPath: string = jsDevTools.getParentFolderPath(packageRootFilePath);
                                      if (!jsDevTools.contains(changedPackageFolders, packageFolderPath)) {
                                        changedPackageFolders.push(packageFolderPath);
                                      }
                                    }
                                  }
                                  await repoLogger.logInfo(`Found ${changedPackageFolders.length} package folder${changedPackageFolders.length === 1 ? "" : "s"} that changed:`);
                                  for (const changedPackageFolder of changedPackageFolders) {
                                    await repoLogger.logInfo(`  ${changedPackageFolder}`);
                                  }

                                  if (!repositoryLanguage.packageCommands || repositoryLanguage.packageCommands.length === 0) {
                                    await repoLogger.logWarning(`${repositoryLanguage.name} has no registered package commands.`);
                                  } else {
                                    if (!repositoryLanguage.packageFileExtension) {
                                      await repoLogger.logWarning(`${repositoryLanguage.name} has no registered package file extension.`);
                                    }

                                    for (const changedPackageFolder of changedPackageFolders) {
                                      for (const packageCommand of repositoryLanguage.packageCommands) {
                                        let commandResult: Promise<RunResult>;
                                        if (typeof packageCommand === "string") {
                                          const packageCommandArray: string[] = packageCommand.split(" ");
                                          const command: string = packageCommandArray.shift()!;
                                          const args: string[] = packageCommandArray;
                                          commandResult = run(command, args, {
                                            executionFolderPath: changedPackageFolder,
                                            runner: generation.runner,
                                            showCommand: true,
                                            showResult: true,
                                            captureOutput: repoLogger.logInfo,
                                            captureError: repoLogger.logInfo,
                                            log: repoLogger.logInfo
                                          });
                                        } else {
                                          commandResult = packageCommand(
                                            {
                                              packageFolderPath: changedPackageFolder,
                                              executionFolderPath: changedPackageFolder,
                                              compressor: generation.compressorCreator(),
                                              runner: generation.runner,
                                              log: repoLogger.logInfo,
                                              showCommand: true,
                                              showResult: true,
                                              captureOutput: repoLogger.logInfo,
                                              captureError: repoLogger.logInfo,
                                            })
                                            .then(() => { return { exitCode: 0 }; })
                                            .catch((error: Error) => { return { error }; });
                                        }
                                        const packageCommandResult: RunResult = await commandResult;
                                        if (packageCommandResult.exitCode !== 0) {
                                          break;
                                        }
                                      }

                                      if (repositoryLanguage.packageFileExtension) {
                                        const packageFileExtension: string = repositoryLanguage.packageFileExtension;
                                        const packagedFilePaths: string[] | undefined = getChildFilePaths(changedPackageFolder, {
                                          recursive: true,
                                          fileCondition: (filePath: string) => filePath.endsWith(packageFileExtension)
                                        });
                                        if (!packagedFilePaths || packagedFilePaths.length === 0) {
                                          await repoLogger.logWarning(`No package files found in ${changedPackageFolder}.`);
                                        } else {
                                          await repoLogger.logInfo(`Found ${packagedFilePaths.length} package file${packagedFilePaths.length === 1 ? "" : "s"} in ${changedPackageFolder}:`);
                                          for (const packageFilePath of packagedFilePaths) {
                                            await repoLogger.logInfo(`  ${packageFilePath}`);
                                          }

                                          for (const packageFilePath of packagedFilePaths) {
                                            const packageFileName: string = path.basename(packageFilePath);
                                            const packageFileBlob: jsDevTools.BlobStorageBlob = generationInstancePrefix.getBlob(joinPath(fullRepositoryName, packageFileName));
                                            const packageFileBlobUrl: string = URLBuilder.parse(packageFileBlob.getURL()).setQuery(undefined).toString();
                                            await repoLogger.logSection(`Uploading ${packageFilePath} to ${packageFileBlobUrl}...`);
                                            await packageFileBlob.setContentsFromFile(packageFilePath);
                                            await repoLogger.logInfo(`Done uploading ${packageFilePath} to ${packageFileBlobUrl}.`);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }

                        if (generationRepository.status === "inProgress") {
                          generationRepository.status = "succeeded";
                          await postGenerationState(generation);
                        }

                        if (!generation.deleteClonedRepositories) {
                          await repoLogger.logInfo(`Not deleting clone of ${fullRepositoryName} at folder ${repositoryFolderPath}.`);
                        } else {
                          await repoLogger.logSection(`Deleting clone of ${fullRepositoryName} at folder ${repositoryFolderPath}...`);
                          jsDevTools.deleteFolder(repositoryFolderPath);
                          await repoLogger.logInfo(`Finished deleting clone of ${fullRepositoryName} at folder ${repositoryFolderPath}.`);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } finally {
    if (!generation.deleteClonedRepositories) {
      await logger.logInfo(`Not deleting working folder ${generation.workingFolderPath}.`);
    } else {
      await logger.logSection(`Deleting working folder ${generation.workingFolderPath}...`);
      jsDevTools.deleteFolder(generation.workingFolderPath);
      await logger.logInfo(`Finished deleting working folder ${generation.workingFolderPath}.`);
    }
  }
}

function writeGenerationDataToBlob(blob: BlobStorageBlob, generationData: GenerationData): Promise<any> {
  return blob.setContentsFromString(
    JSON.stringify(generationData, undefined, 2),
    { contentType: "text/json" });
}

/**
 * Get the HTML lines that describes the current state of a generation.
 * @param generationData The current state of a generation.
 */
export function getGenerationDataHTMLLines(generationData?: GenerationData): string[] {
  const result: string[] = [];
  result.push(`<html>`);
  result.push(`<body>`);
  result.push(`<h1>Generation Progress</h1>`);
  if (generationData) {
    result.push(`<a href="${generationData.logsBlobUrl}">Generation Logs</a>`);
    if (generationData.repositories) {
      const repositoryFullNames: string[] = Object.keys(generationData.repositories);
      if (repositoryFullNames && repositoryFullNames.length > 0) {
        result.push(`<table>`);
        for (const repositoryFullName of repositoryFullNames) {
          const generationRepository: GenerationRepository = generationData.repositories[repositoryFullName];

          result.push(`<tr>`);
          result.push(`<td><a href="https://github.com/${repositoryFullName}">${repositoryFullName}</a></td>`);
          result.push(`<td>${generationStatus[generationRepository.status]}</td>`);
          if (generationRepository.logsBlobUrl) {
            result.push(`<td><a href="${generationRepository.logsBlobUrl}">Logs</a></td>`);
          }
          if (generationRepository.pullRequestUrl) {
            result.push(`<td><a href="${generationRepository.pullRequestUrl}">Pull Request</a></td>`);
          }
          result.push(`</tr>`);

          if (generationRepository.packages && generationRepository.packages.length > 0) {
            for (const generationRepositoryPackage of generationRepository.packages) {
              result.push(`<tr>`);
              result.push(`<td>${generationRepositoryPackage.name}</td>`);
              result.push(`<td>${generationStatus[generationRepositoryPackage.status]}</td>`);
              if (generationRepositoryPackage.logsBlobUrl) {
                result.push(`<td><a href="${generationRepositoryPackage.logsBlobUrl}">Logs</a></td>`);
              }
              if (generationRepositoryPackage.packageBlobUrl) {
                result.push(`<td><a href="${generationRepositoryPackage.packageBlobUrl}">Download</a></td>`);
              }
              result.push(`<tr>`);
            }
          }
        }
        result.push(`</table>`);
      }
    }
  }
  result.push(`</body>`);
  result.push(`</html>`);
  return result;
}

export function getGenerationDataHTML(generationData?: GenerationData): string {
  return getGenerationDataHTMLLines(generationData).join("");
}
